# =============================================================================
# Force Remediation - Fabric User Data Function
# =============================================================================
#
# This file implements a Fabric User Data Function that executes remediation
# scripts generated by the Force Lakehouse & Warehouse Scanners.
#
# DEPLOYMENT:
#   1. Create a new "User Data Functions" item in your Fabric workspace
#   2. Copy this code into the function editor
#   3. Add data connections via "Manage Connections":
#      - Your Fabric Warehouse (alias: "TargetWarehouse")
#      - Your Fabric Lakehouse SQL Endpoint (alias: "TargetLakehouse") [read-only]
#   4. Publish the function
#   5. Connect it to a Power BI report button (Translytical Task Flow)
#
# SECURITY NOTE:
#   The function validates scripts against an allowlist of safe commands
#   before execution. Arbitrary SQL is rejected.
#
# POWER BI INTEGRATION:
#   In your Power BI report, add a "Data function" button:
#   1. Enable Preview Feature: "Translytical task flows" in Power BI Desktop
#   2. Insert > Button > Data function
#   3. Connect to this User Data Function
#   4. Map the "remediationScript" parameter to the remediation_script column
#   5. Optionally map "scriptType" to "warehouse" or "lakehouse"
# =============================================================================

import fabric.functions as fn
import logging
import re

udf = fn.UserDataFunctions()

# ---------------------------------------------------------------------------
# Allowlist of safe SQL/Spark command prefixes
# Only scripts starting with one of these patterns will be executed.
# ---------------------------------------------------------------------------
ALLOWED_WAREHOUSE_PREFIXES = [
    "ALTER DATABASE",
    "ALTER TABLE",
    "UPDATE STATISTICS",
    "ADD SENSITIVITY CLASSIFICATION",
]

ALLOWED_LAKEHOUSE_PREFIXES = [
    "VACUUM",
    "OPTIMIZE",
    "ALTER TABLE",
    "ANALYZE TABLE",
]


def validate_script(script: str, scriptType: str) -> bool:
    """
    Validate that the remediation script starts with an allowed command.
    Returns True if the script is safe to execute, False otherwise.
    """
    if not script or not script.strip():
        return False

    normalized = script.strip().upper()

    if scriptType == "warehouse":
        return any(normalized.startswith(prefix) for prefix in ALLOWED_WAREHOUSE_PREFIXES)
    elif scriptType == "lakehouse":
        return any(normalized.startswith(prefix) for prefix in ALLOWED_LAKEHOUSE_PREFIXES)
    else:
        return False


# ---------------------------------------------------------------------------
# Main function: Execute a warehouse remediation script
# ---------------------------------------------------------------------------
# NOTE: Replace the alias "TargetWarehouse" with the alias of YOUR
#       Warehouse data connection (configured via Manage Connections).
# ---------------------------------------------------------------------------
@udf.connection(argName="warehouseConn", alias="TargetWarehouse")
@udf.function()
def executeWarehouseRemediation(
    warehouseConn: fn.FabricSqlConnection,
    remediationScript: str,
) -> dict:
    """
    Execute a warehouse remediation script from a Power BI report button.

    Args:
        warehouseConn: Fabric Warehouse SQL connection (injected via decorator)
        remediationScript: The SQL remediation script to execute

    Returns:
        dict with status, message, and the executed script
    """
    logging.info(f"Received warehouse remediation request: {remediationScript[:100]}...")

    # Validate the script
    if not validate_script(remediationScript, "warehouse"):
        logging.warning(f"Script rejected by allowlist: {remediationScript[:100]}")
        raise fn.UserThrownError(
            "Script rejected: only ALTER DATABASE, ALTER TABLE, UPDATE STATISTICS, "
            "and ADD SENSITIVITY CLASSIFICATION commands are allowed.",
            {"script": remediationScript[:200]}
        )

    # Execute the script
    try:
        connection = warehouseConn.connect()
        cursor = connection.cursor()

        # Handle multi-statement scripts (separated by semicolons)
        statements = [s.strip() for s in remediationScript.split(";") if s.strip()]

        for statement in statements:
            logging.info(f"Executing: {statement[:100]}...")
            cursor.execute(statement)

        cursor.close()
        connection.close()

        logging.info("Warehouse remediation executed successfully.")
        return {
            "status": "success",
            "message": f"Executed {len(statements)} statement(s) successfully.",
            "script": remediationScript
        }

    except Exception as e:
        logging.error(f"Warehouse remediation failed: {str(e)}")
        raise fn.UserThrownError(
            f"Execution failed: {str(e)}",
            {"script": remediationScript[:200]}
        )


# ---------------------------------------------------------------------------
# Lakehouse remediation via Notebook REST API
# ---------------------------------------------------------------------------
# Lakehouse commands (VACUUM, OPTIMIZE) require Spark execution.
# This function triggers a parameterized Fabric Notebook via REST API.
#
# SETUP:
#   1. Create a notebook "force_remediation_executor" in your workspace
#      with a parameter cell accepting: remediation_script (str)
#   2. Set WORKSPACE_ID and NOTEBOOK_ID below
#   3. The notebook should execute: spark.sql(remediation_script)
# ---------------------------------------------------------------------------
@udf.function()
def executeLakehouseRemediation(
    remediationScript: str,
    workspaceId: str,
    notebookId: str,
) -> dict:
    """
    Trigger a Fabric Notebook to execute a Lakehouse remediation script.

    Args:
        remediationScript: The Spark SQL remediation script (VACUUM, OPTIMIZE, etc.)
        workspaceId: The Fabric workspace ID containing the executor notebook
        notebookId: The ID of the force_remediation_executor notebook

    Returns:
        dict with status and the triggered job details
    """
    import requests

    logging.info(f"Received lakehouse remediation request: {remediationScript[:100]}...")

    # Validate the script
    if not validate_script(remediationScript, "lakehouse"):
        logging.warning(f"Script rejected by allowlist: {remediationScript[:100]}")
        raise fn.UserThrownError(
            "Script rejected: only VACUUM, OPTIMIZE, ALTER TABLE, "
            "and ANALYZE TABLE commands are allowed.",
            {"script": remediationScript[:200]}
        )

    # Trigger the notebook via Fabric REST API
    try:
        # Get token for Fabric API
        from notebookutils import credentials
        token = credentials.getToken("https://api.fabric.microsoft.com")

        url = (
            f"https://api.fabric.microsoft.com/v1/workspaces/{workspaceId}"
            f"/items/{notebookId}/jobs/instances?jobType=RunNotebook"
        )

        payload = {
            "executionData": {
                "parameters": {
                    "remediation_script": {
                        "value": remediationScript,
                        "type": "string"
                    }
                }
            }
        }

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        response = requests.post(url, json=payload, headers=headers)

        if response.status_code == 202:
            job_location = response.headers.get("Location", "")
            logging.info(f"Notebook triggered successfully. Job: {job_location}")
            return {
                "status": "triggered",
                "message": "Notebook execution started. Check job status for completion.",
                "script": remediationScript,
                "jobLocation": job_location
            }
        else:
            raise Exception(f"API returned {response.status_code}: {response.text[:200]}")

    except Exception as e:
        logging.error(f"Lakehouse remediation trigger failed: {str(e)}")
        raise fn.UserThrownError(
            f"Failed to trigger notebook: {str(e)}",
            {"script": remediationScript[:200]}
        )
