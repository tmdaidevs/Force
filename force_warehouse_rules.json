{
  "rules": [
    {
      "id": "RL001",
      "category": "Data Quality",
      "description": "Check for NULL values in columns across all tables. Returns columns with NULL values and their percentage.",
      "sql_query": "DECLARE @sql NVARCHAR(MAX) = '';\n\nSELECT @sql = @sql +\n  'SELECT ''' + TABLE_SCHEMA + '.' + TABLE_NAME + ''' AS table_name, ' +\n  '''' + COLUMN_NAME + ''' AS column_name, ' +\n  'CASE WHEN SUM(CASE WHEN ' + QUOTENAME(COLUMN_NAME) + ' IS NULL THEN 1 ELSE 0 END) > 0 ' +\n  'THEN ''NULL Analysis: '' + CAST(SUM(CASE WHEN ' + QUOTENAME(COLUMN_NAME) + ' IS NULL THEN 1 ELSE 0 END) AS VARCHAR(10)) + '' of '' + CAST(COUNT(*) AS VARCHAR(10)) + '' rows are NULL ('' + CAST(CAST(100.0 * SUM(CASE WHEN ' + QUOTENAME(COLUMN_NAME) + ' IS NULL THEN 1 ELSE 0 END) / NULLIF(COUNT(*),0) AS DECIMAL(5,2)) AS VARCHAR(10)) + ''%).'' + CHAR(10) + ' +\n  'CASE ' +\n    'WHEN CAST(100.0 * SUM(CASE WHEN ' + QUOTENAME(COLUMN_NAME) + ' IS NULL THEN 1 ELSE 0 END) / NULLIF(COUNT(*),0) AS DECIMAL(5,2)) > 90 THEN ''CRITICAL: Over 90% NULL - column may be unnecessary.'' ' +\n    'WHEN CAST(100.0 * SUM(CASE WHEN ' + QUOTENAME(COLUMN_NAME) + ' IS NULL THEN 1 ELSE 0 END) / NULLIF(COUNT(*),0) AS DECIMAL(5,2)) > 50 THEN ''WARNING: Over 50% of rows have NULL values.'' ' +\n    'WHEN CAST(100.0 * SUM(CASE WHEN ' + QUOTENAME(COLUMN_NAME) + ' IS NULL THEN 1 ELSE 0 END) / NULLIF(COUNT(*),0) AS DECIMAL(5,2)) > 10 THEN ''NOTICE: Significant NULL values detected.'' ' +\n    'ELSE ''INFO: Some NULL values present, verify if expected.'' ' +\n  'END + CHAR(10) + CHAR(10) + ''Indicator: Anomaly - ERR_1001'' ' +\n  'ELSE ''NULL Analysis: 0 of '' + CAST(COUNT(*) AS VARCHAR(10)) + '' rows are NULL (0%). Column is fully populated.'' + CHAR(10) + CHAR(10) + ''Indicator: Optimized - OPT_2001'' ' +\n  'END AS result ' +\n  'FROM ' + QUOTENAME(TABLE_SCHEMA) + '.' + QUOTENAME(TABLE_NAME) + ' ' +\n  'UNION ALL '\nFROM INFORMATION_SCHEMA.COLUMNS\nWHERE TABLE_SCHEMA NOT IN ('sys', 'INFORMATION_SCHEMA', 'queryinsights')\n  AND DATA_TYPE NOT IN ('text','ntext','image');\n\nIF LEN(@sql) > 0\nBEGIN\n  SET @sql = LEFT(@sql, LEN(@sql) - LEN(' UNION ALL '));\n  EXEC sp_executesql @sql;\nEND\nELSE\nBEGIN\n  SELECT NULL AS table_name, NULL AS column_name, 'No columns found to analyze for NULL values.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result;\nEND",
      "recommendation": "Review columns with high NULL percentages to determine if this is expected or indicates data quality issues. Consider adding NOT NULL constraints for columns where NULLs are not acceptable, or providing default values where appropriate. For columns with near 100% NULL values, evaluate if they're actually needed in the table schema. For mission-critical tables, aim for complete data with minimal NULL values in required fields.",
      "status": "true",
      "severity": 2,
      "content": "query",
      "level": "column"
    },
    {
      "id": "RL002",
      "category": "Performance",
      "description": "List all triggers on user tables to review potential performance impacts.",
      "sql_query": "DECLARE @sql NVARCHAR(MAX) = N'';\nDECLARE @has_triggers BIT = 0;\n\n-- Check for any triggers\nIF EXISTS (SELECT 1 FROM sys.triggers)\nBEGIN\n    SET @has_triggers = 1;\n    SET @sql = N'\n        SELECT TOP 100 PERCENT\n            t.name AS table_name,\n            tr.name AS column_name,\n            ''Performance Issue: Trigger defined on table '' + t.name + '' (trigger: '' + tr.name + '')'' + CHAR(10) + CHAR(10) + ''Indicator: Anomaly - ERR_1001'' AS result\n        FROM sys.triggers tr\n        JOIN sys.tables t ON tr.parent_id = t.object_id\n        ORDER BY t.name, tr.name;';\n    EXEC sp_executesql @sql;\nEND;\n\nIF @has_triggers = 0\nBEGIN\n    SELECT\n        t.name AS table_name,\n        NULL AS column_name,\n        'Performance Check: No triggers found on user table: ' + t.name + '. This indicates that DML operations (INSERT/UPDATE/DELETE) are not subject to trigger overhead. If you rely on triggers for audit, validation, or other business logic, consider whether any are needed.'\n        + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result\n    FROM sys.tables t\n    WHERE t.is_ms_shipped = 0\n    ORDER BY t.name;\nEND",
      "recommendation": "Review triggers to ensure they are necessary and written efficiently. Consider disabling or refactoring rarely used or heavy triggers to improve DML performance.",
      "status": "false",
      "fabric_note": "Disabled: Triggers are not supported in Microsoft Fabric Warehouse.",
      "severity": 3,
      "content": "query",
      "level": "table"
    },
    {
      "id": "RL003",
      "category": "Data Quality",
      "description": "Check for disabled or untrusted foreign keys or constraints, which can break data integrity.",
      "sql_query": "SELECT \n  SCHEMA_NAME(t.schema_id) + '.' + t.name AS table_name,\n  NULL AS column_name,\n  CASE \n    WHEN f.bad_fk_count > 0 THEN 'Data Quality Issue: Table ' + t.name + ' has disabled/untrusted foreign keys: ' + f.bad_fk_names + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001'\n    WHEN f.total_fk_count = 0 THEN 'Data Quality Check: Table ' + t.name + ' has no foreign keys defined. This might compromise referential integrity.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001'\n    ELSE 'Data Quality Check: Table ' + t.name + ' has trusted and enabled foreign keys.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001'\n  END AS result\nFROM sys.tables t\nOUTER APPLY (\n  SELECT \n    COUNT(*) AS total_fk_count,\n    STRING_AGG(name, ', ') AS bad_fk_names,\n    SUM(CASE WHEN is_disabled = 1 OR is_not_trusted = 1 THEN 1 ELSE 0 END) AS bad_fk_count\n  FROM sys.foreign_keys\n  WHERE parent_object_id = t.object_id\n) f\nWHERE t.is_ms_shipped = 0\nORDER BY t.name;",
      "recommendation": "Enable or re-validate any disabled or untrusted foreign keys to ensure referential integrity is enforced.",
      "remediation_template": "ALTER TABLE {table_name} WITH CHECK CHECK CONSTRAINT ALL",
      "status": "true",
      "severity": 1,
      "content": "query",
      "level": "table"
    },
    {
      "id": "RL004",
      "category": "Maintainability",
      "description": "List stored procedures that lack extended property documentation.",
      "sql_query": "DECLARE @sql NVARCHAR(MAX) = N'';\nDECLARE @has_procs BIT = 0;\nDECLARE @has_undoc BIT = 0;\n\n-- 1) keine Prozeduren vorhanden?\nIF NOT EXISTS (SELECT 1 FROM sys.procedures)\nBEGIN\n    SELECT\n      NULL AS table_name,\n      NULL             AS column_name,\n      'No stored procedures found in database.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result;\nEND\nELSE\nBEGIN\n    SET @has_procs = 1;\n\n    -- 2) gibt es un-dokumentierte Prozeduren?\n    IF EXISTS (\n      SELECT 1\n      FROM sys.procedures o\n      LEFT JOIN sys.extended_properties ep\n        ON o.object_id = ep.major_id\n       AND ep.minor_id = 0\n       AND ep.name = 'MS_Description'\n      WHERE ep.value IS NULL\n    )\n    BEGIN\n        SET @has_undoc = 1;\n        SET @sql = N'\n            SELECT TOP 100 PERCENT\n                o.name AS table_name,\n                NULL   AS column_name,\n                ''Stored procedure '' + o.name + '' lacks extended-property documentation''\n                + CHAR(10) + CHAR(10) + ''Indicator: Anomaly - ERR_1001'' AS result\n            FROM sys.procedures o\n            LEFT JOIN sys.extended_properties ep\n              ON o.object_id = ep.major_id\n             AND ep.minor_id = 0\n             AND ep.name = ''MS_Description''\n            WHERE ep.value IS NULL\n            ORDER BY o.name;';\n        EXEC sp_executesql @sql;\n    END;\n\n    -- 3) alle Prozeduren dokumentiert\n    IF @has_procs = 1 AND @has_undoc = 0\n    BEGIN\n        SELECT\n          NULL AS table_name,\n          NULL             AS column_name,\n          'All stored procedures have extended-property documentation. Analyzed procedures: ' +\n          (SELECT STRING_AGG(name, ', ') FROM sys.procedures) +\n          '.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result;\n    END;\nEND",
      "recommendation": "Document stored procedures using extended properties (e.g. MS_Description) to improve maintainability and onboarding.",
      "status": "true",
      "severity": 3,
      "content": "query",
      "level": "database"
    },
    {
      "id": "RL005",
      "category": "Maintainability",
      "description": "Identify views that use 'SELECT *', which can lead to maintenance and performance issues.",
      "sql_query": "DECLARE @sql NVARCHAR(MAX) = N'';\nDECLARE @has_issues BIT = 0;\n\n-- Check for any user-defined views using SELECT *\nIF EXISTS (\n    SELECT 1\n    FROM sys.views v\n    JOIN sys.sql_modules m ON v.object_id = m.object_id\n    WHERE m.definition LIKE '%SELECT *%'\n      AND SCHEMA_NAME(v.schema_id) <> 'sys'\n      AND v.name NOT IN ('exec_requests_history','long_running_queries','frequently_run_queries','exec_sessions_history')\n)\nBEGIN\n    SET @has_issues = 1;\n    SET @sql = N'\n        SELECT TOP 100 PERCENT\n            SCHEMA_NAME(v.schema_id) + ''.'' + v.name AS table_name,\n            NULL AS column_name,\n            ''View '' + SCHEMA_NAME(v.schema_id) + ''.'' + v.name + '' uses SELECT * pattern'' + CHAR(10) + CHAR(10) + ''Indicator: Anomaly - ERR_1001'' AS result\n        FROM sys.views v\n        JOIN sys.sql_modules m ON v.object_id = m.object_id\n        WHERE m.definition LIKE ''%SELECT *%''\n          AND SCHEMA_NAME(v.schema_id) <> ''sys''\n          AND v.name NOT IN (''exec_requests_history'',''long_running_queries'',''frequently_run_queries'',''exec_sessions_history'')\n        ORDER BY SCHEMA_NAME(v.schema_id), v.name;';\n    EXEC sp_executesql @sql;\nEND;\n\nIF @has_issues = 0\nBEGIN\n    SELECT\n        SCHEMA_NAME(v.schema_id) + '.' + v.name AS table_name,\n        NULL AS column_name,\n        'The view does not contain the pattern SELECT *. This view (' + SCHEMA_NAME(v.schema_id) + '.' + v.name + ') specifies explicit column lists to reduce maintenance risk.' \n          + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result\n    FROM sys.views v\n    WHERE SCHEMA_NAME(v.schema_id) <> 'sys'\n      AND v.name NOT IN ('exec_requests_history','long_running_queries','frequently_run_queries','exec_sessions_history')\n    ORDER BY SCHEMA_NAME(v.schema_id), v.name;\nEND",
      "recommendation": "Refactor any views that use SELECT * to explicitly list the columns they need, preventing unintended side-effects when underlying tables change.",
      "status": "true",
      "severity": 3,
      "content": "query",
      "level": "table"
    },
    {
      "id": "RL006",
      "category": "Security",
      "description": "Identify orphaned database users that are not mapped to any login.",
      "sql_query": "DECLARE @has_issues BIT = 0;\n\n\t\t-- Prüfe auf orphaned Users\n\t\tIF EXISTS (\n\t\t\tSELECT 1 FROM sys.database_principals dp\n\t\t\tWHERE dp.type_desc IN ('SQL_USER','WINDOWS_USER','WINDOWS_GROUP')\n\t\t\t  AND dp.sid IS NOT NULL\n\t\t\t  AND NOT EXISTS (SELECT 1 FROM sys.server_principals sp WHERE sp.sid = dp.sid)\n\t\t)\n\t\tBEGIN\n\t\t\tSET @has_issues = 1;\n\t\t\tSELECT 'sys.database_principals' AS table_name, dp.name AS column_name, 'Orphaned database user ' + dp.name + ' found. This user is not mapped to any server login, which can lead to security and access issues.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\n\t\t\tFROM sys.database_principals dp\n\t\t\tWHERE dp.type_desc IN ('SQL_USER','WINDOWS_USER','WINDOWS_GROUP')\n\t\t\t  AND dp.sid IS NOT NULL\n\t\t\t  AND NOT EXISTS (SELECT 1 FROM sys.server_principals sp WHERE sp.sid = dp.sid)\n\t\t\tORDER BY dp.name;\n\t\tEND;\n\n\t\tIF @has_issues = 0\n\t\tBEGIN\n\t\t\tSELECT 'sys.database_principals' AS table_name, NULL AS column_name, 'No orphaned database users found in sys.database_principals. All database users are properly mapped to server principals, ensuring security and integrity.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result;\n\t\tEND",
      "recommendation": "Review orphaned users and remove or map them appropriately to reduce potential security risks.",
      "status": "false",
      "fabric_note": "Disabled: Fabric uses Entra ID authentication. sys.server_principals is not applicable.",
      "severity": 2,
      "content": "query",
      "level": "database"
    },
    {
      "id": "RL007",
      "category": "Data Quality",
      "description": "Check which columns are used as foreign keys in the warehouse.",
      "sql_query": "DECLARE @has_fks BIT = 0;\n\n-- Check for any foreign key columns\nIF EXISTS (\n    SELECT 1\n    FROM INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE ccu\n    JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc\n      ON ccu.CONSTRAINT_NAME = tc.CONSTRAINT_NAME\n     AND ccu.TABLE_SCHEMA = tc.TABLE_SCHEMA\n     AND ccu.TABLE_NAME = tc.TABLE_NAME\n    WHERE tc.CONSTRAINT_TYPE = 'FOREIGN KEY'\n)\nBEGIN\n    SET @has_fks = 1;\n    SELECT\n        ccu.TABLE_SCHEMA + '.' + ccu.TABLE_NAME AS table_name,\n        ccu.COLUMN_NAME AS column_name,\n        'Column ' + ccu.COLUMN_NAME + ' in table ' + ccu.TABLE_NAME + ' is used as a foreign key. This enforces referential integrity but may impact performance on large joins.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\n    FROM INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE ccu\n    JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc\n      ON ccu.CONSTRAINT_NAME = tc.CONSTRAINT_NAME\n     AND ccu.TABLE_SCHEMA = tc.TABLE_SCHEMA\n     AND ccu.TABLE_NAME = tc.TABLE_NAME\n    WHERE tc.CONSTRAINT_TYPE = 'FOREIGN KEY';\nEND;\n\nIF @has_fks = 0\nBEGIN\n    SELECT\n        NULL AS table_name,\n        NULL AS column_name,\n        'No foreign key columns found. The warehouse does not define any referential constraints at column level, which may lead to orphaned records or data integrity issues.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result;\nEND",
      "recommendation": "Having proper foreign keys helps document referential integrity. If missing, consider defining them.",
      "status": "true",
      "severity": 3,
      "content": "query",
      "level": "schema"
    },
    {
      "id": "RL008",
      "category": "Data Quality",
      "description": "Find any columns using floating-point types (float/real) in the dbo schema.",
      "sql_query": "DECLARE @has_fp BIT = 0;\n\n-- Check for any float/real columns in dbo schema\nIF EXISTS (\n    SELECT 1\n    FROM INFORMATION_SCHEMA.COLUMNS\n    WHERE TABLE_SCHEMA NOT IN ('sys', 'INFORMATION_SCHEMA', 'queryinsights')\n      AND DATA_TYPE IN ('float','real')\n)\nBEGIN\n    SET @has_fp = 1;\n    SELECT\n        TABLE_SCHEMA + '.' + TABLE_NAME AS table_name,\n        COLUMN_NAME AS column_name,\n        'Column ' + COLUMN_NAME + ' in table ' + TABLE_NAME + ' uses floating-point type ' + DATA_TYPE + '. This can lead to precision issues; consider DECIMAL or INT instead.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\n    FROM INFORMATION_SCHEMA.COLUMNS\n    WHERE TABLE_SCHEMA NOT IN ('sys', 'INFORMATION_SCHEMA', 'queryinsights')\n      AND DATA_TYPE IN ('float','real')\n    ORDER BY TABLE_NAME, COLUMN_NAME;\nEND;\n\nIF @has_fp = 0\nBEGIN\n    SELECT\n        NULL AS table_name,\n        NULL AS column_name,\n        'No floating-point columns found in dbo schema. All numeric columns use fixed-precision types, reducing risk of precision loss.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result;\nEND",
      "recommendation": "Floating-point types can cause precision issues. Consider using DECIMAL or INT types where exact values are required.",
      "status": "true",
      "severity": 3,
      "content": "query",
      "level": "schema"
    },
    {
      "id": "RL009",
      "category": "Data Quality",
      "description": "Ensure every table that needs unique rows has a primary key or unique constraint (not enforced).",
      "sql_query": "DECLARE @has_issue BIT = 0;\n\nIF EXISTS (\n  SELECT 1\n  FROM sys.tables t\n  LEFT JOIN sys.indexes i ON t.object_id=i.object_id AND i.is_primary_key=1\n  WHERE i.object_id IS NULL AND t.is_ms_shipped=0\n)\nBEGIN\n  SET @has_issue = 1;\n  SELECT\n    SCHEMA_NAME(t.schema_id) + '.' + t.name AS table_name,\n    NULL        AS column_name,\n    'Table ' + t.name + ' is missing a primary key or unique constraint. Without one, duplicate rows cannot be prevented, harming data integrity.' + CHAR(10)+CHAR(10)+'Indicator: Anomaly - ERR_1001' AS result\n  FROM sys.tables t\n  LEFT JOIN sys.indexes i ON t.object_id=i.object_id AND i.is_primary_key=1\n  WHERE i.object_id IS NULL AND t.is_ms_shipped=0;\nEND\nELSE\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'All user tables have a primary key or unique constraint. This ensures each row is uniquely identifiable and prevents duplicates.' + CHAR(10)+CHAR(10)+'Indicator: Optimized - OPT_2001' AS result;\nEND",
      "recommendation": "Define a primary key or unique constraint on tables that require row uniqueness to enforce data integrity and improve performance of joins.",
      "status": "true",
      "severity": 1,
      "content": "query",
      "level": "table"
    },
    {
      "id": "RL010",
      "category": "Maintainability",
      "description": "Use consistent column naming conventions (no spaces, special characters, etc.).",
      "sql_query": "DECLARE @has_issue BIT = 0;\n\nIF EXISTS (\n  SELECT 1\n  FROM sys.tables t\n  JOIN sys.columns c ON t.object_id=c.object_id\n  WHERE c.name COLLATE Latin1_General_BIN LIKE '%[^a-zA-Z0-9_]%' \n)\nBEGIN\n  SET @has_issue = 1;\n  SELECT\n    t.name   AS table_name,\n    c.name   AS column_name,\n    'Column ' + QUOTENAME(c.name) + ' in table ' + t.name + ' contains invalid characters. Use only letters, digits or underscores to improve readability and tooling support.' + CHAR(10)+CHAR(10)+'Indicator: Anomaly - ERR_1001' AS result\n  FROM sys.tables t\n  JOIN sys.columns c ON t.object_id=c.object_id\n  WHERE c.name COLLATE Latin1_General_BIN LIKE '%[^a-zA-Z0-9_]%';\nEND\nELSE\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'All column names follow the convention of letters, digits, and underscores. This consistency simplifies code maintenance and tooling.' + CHAR(10)+CHAR(10)+'Indicator: Optimized - OPT_2001' AS result;\nEND",
      "recommendation": "Rename columns to remove spaces and special characters. Consistent naming improves readability, reduces bugs, and enhances tool compatibility.",
      "status": "true",
      "severity": 3,
      "content": "query",
      "level": "table"
    },
    {
      "id": "RL011",
      "category": "Maintainability",
      "description": "Avoid using deprecated data types like TEXT, NTEXT, IMAGE; use VARCHAR(MAX), NVARCHAR(MAX), or VARBINARY(MAX).",
      "sql_query": "DECLARE @has_issue BIT = 0;\n\nIF EXISTS (\n  SELECT 1\n  FROM sys.tables t\n  JOIN sys.columns c ON t.object_id=c.object_id\n  JOIN sys.types typ ON c.user_type_id=typ.user_type_id\n  WHERE typ.name IN('text','ntext','image')\n)\nBEGIN\n  SET @has_issue = 1;\n  SELECT\n    SCHEMA_NAME(t.schema_id) + '.' + t.name AS table_name,\n    c.name       AS column_name,\n    'Column ' + c.name + ' in table ' + t.name + ' uses deprecated type ' + typ.name + '. Migrate to VARCHAR(MAX)/NVARCHAR(MAX)/VARBINARY(MAX) for better support.' + CHAR(10)+CHAR(10)+'Indicator: Anomaly - ERR_1001' AS result\n  FROM sys.tables t\n  JOIN sys.columns c ON t.object_id=c.object_id\n  JOIN sys.types typ ON c.user_type_id=typ.user_type_id\n  WHERE typ.name IN('text','ntext','image');\nEND\nELSE\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'No deprecated data types found. All large object columns use modern MAX types, ensuring better performance and future compatibility.' + CHAR(10)+CHAR(10)+'Indicator: Optimized - OPT_2001' AS result;\nEND",
      "recommendation": "Change TEXT/NTEXT/IMAGE columns to VARCHAR(MAX), NVARCHAR(MAX), or VARBINARY(MAX) to leverage current SQL Server features and avoid deprecation issues.",
      "status": "true",
      "severity": 2,
      "content": "query",
      "level": "schema"
    },
    {
      "id": "RL012",
      "category": "Security",
      "description": "Use dynamic data masking to obfuscate sensitive fields for certain roles/users.",
      "sql_query": "DECLARE @has_mask BIT = 0;\n\nIF EXISTS (SELECT 1 FROM sys.masked_columns)\nBEGIN\n  SET @has_mask = 1;\n  SELECT\n    OBJECT_SCHEMA_NAME(c.object_id) + '.' + OBJECT_NAME(c.object_id) AS table_name,\n    c.name COLLATE Latin1_General_100_BIN2_UTF8 AS column_name,\n    'Column ' + c.name COLLATE Latin1_General_100_BIN2_UTF8 + ' in ' + OBJECT_SCHEMA_NAME(c.object_id) + '.' + OBJECT_NAME(c.object_id) + ' uses masking function ' + m.masking_function COLLATE Latin1_General_100_BIN2_UTF8 + '. This protects sensitive data but may impact query performance.' + CHAR(10)+CHAR(10)+'Indicator: Anomaly - ERR_1001' AS result\n  FROM sys.masked_columns m\n  JOIN sys.columns c ON m.object_id=c.object_id AND m.column_id=c.column_id;\nEND\nELSE\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'No columns with dynamic data masking found. Consider applying masks to sensitive columns (e.g., Email, SSN) to reduce data exposure risk.' + CHAR(10)+CHAR(10)+'Indicator: Optimized - OPT_2001' AS result;\nEND",
      "recommendation": "Implement dynamic data masking on PII columns to limit data exposure for non-privileged users while retaining query functionality.",
      "status": "true",
      "severity": 1,
      "content": "query",
      "level": "schema"
    },
    {
      "id": "RL013",
      "category": "Data Quality",
      "description": "Check foreign key relationships to ensure child and parent columns have matching data types.",
      "sql_query": "DECLARE @has_issue BIT = 0;\n\nIF EXISTS (\n  SELECT 1\n  FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS fk\n  JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu_child\n    ON fk.CONSTRAINT_NAME = kcu_child.CONSTRAINT_NAME\n  JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu_parent\n    ON fk.UNIQUE_CONSTRAINT_NAME = kcu_parent.CONSTRAINT_NAME\n   AND kcu_child.ORDINAL_POSITION = kcu_parent.ORDINAL_POSITION\n  JOIN INFORMATION_SCHEMA.COLUMNS c_child\n    ON kcu_child.TABLE_SCHEMA = c_child.TABLE_SCHEMA\n   AND kcu_child.TABLE_NAME   = c_child.TABLE_NAME\n   AND kcu_child.COLUMN_NAME  = c_child.COLUMN_NAME\n  JOIN INFORMATION_SCHEMA.COLUMNS c_parent\n    ON kcu_parent.TABLE_SCHEMA = c_parent.TABLE_SCHEMA\n   AND kcu_parent.TABLE_NAME   = c_parent.TABLE_NAME\n   AND kcu_parent.COLUMN_NAME  = c_parent.COLUMN_NAME\n  WHERE c_child.DATA_TYPE <> c_parent.DATA_TYPE\n)\nBEGIN\n  SET @has_issue = 1;\n  SELECT\n    kcu_child.TABLE_SCHEMA + '.' + kcu_child.TABLE_NAME AS table_name,\n    kcu_child.COLUMN_NAME AS column_name,\n    'Foreign key column ''' + kcu_child.COLUMN_NAME + ''' does not match parent data type ''' + c_parent.DATA_TYPE + '''. Parent column uses ' + c_parent.DATA_TYPE + ', child uses ' + c_child.DATA_TYPE + '. This can lead to implicit conversions or errors; ensure types align.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\n  FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS fk\n  JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu_child\n    ON fk.CONSTRAINT_NAME = kcu_child.CONSTRAINT_NAME\n  JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu_parent\n    ON fk.UNIQUE_CONSTRAINT_NAME = kcu_parent.CONSTRAINT_NAME\n   AND kcu_child.ORDINAL_POSITION = kcu_parent.ORDINAL_POSITION\n  JOIN INFORMATION_SCHEMA.COLUMNS c_child\n    ON kcu_child.TABLE_SCHEMA = c_child.TABLE_SCHEMA\n   AND kcu_child.TABLE_NAME   = c_child.TABLE_NAME\n   AND kcu_child.COLUMN_NAME  = c_child.COLUMN_NAME\n  JOIN INFORMATION_SCHEMA.COLUMNS c_parent\n    ON kcu_parent.TABLE_SCHEMA = c_parent.TABLE_SCHEMA\n   AND kcu_parent.TABLE_NAME   = c_parent.TABLE_NAME\n   AND kcu_parent.COLUMN_NAME  = c_parent.COLUMN_NAME\n  WHERE c_child.DATA_TYPE <> c_parent.DATA_TYPE;\nEND\nELSE\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'No mismatched foreign key data types found. All child and parent columns share identical types, ensuring referential integrity without conversion overhead.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result;\nEND",
      "recommendation": "Align data types between child and parent columns in foreign key relationships. Matching types improves performance and prevents runtime errors.",
      "status": "true",
      "severity": 2,
      "content": "query",
      "level": "schema"
    },
    {
      "id": "RL014",
      "category": "Data Quality",
      "description": "Check if foreign key columns are integer-based rather than strings or other types.",
      "sql_query": "DECLARE @has_issue BIT = 0;\n\n-- Check if any foreign keys exist\nIF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS)\nBEGIN\n  IF EXISTS (\n    SELECT 1\n    FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS fk\n    JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu_child\n      ON fk.CONSTRAINT_NAME = kcu_child.CONSTRAINT_NAME\n    JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu_parent\n      ON fk.UNIQUE_CONSTRAINT_NAME = kcu_parent.CONSTRAINT_NAME\n         AND kcu_child.ORDINAL_POSITION = kcu_parent.ORDINAL_POSITION\n    JOIN INFORMATION_SCHEMA.COLUMNS c_child\n      ON kcu_child.TABLE_SCHEMA = c_child.TABLE_SCHEMA\n         AND kcu_child.TABLE_NAME   = c_child.TABLE_NAME\n         AND kcu_child.COLUMN_NAME  = c_child.COLUMN_NAME\n    JOIN INFORMATION_SCHEMA.COLUMNS c_parent\n      ON kcu_parent.TABLE_SCHEMA = c_parent.TABLE_SCHEMA\n         AND kcu_parent.TABLE_NAME   = c_parent.TABLE_NAME\n         AND kcu_parent.COLUMN_NAME  = c_parent.COLUMN_NAME\n    WHERE c_child.DATA_TYPE NOT IN ('int','bigint','smallint','tinyint')\n       OR c_parent.DATA_TYPE NOT IN ('int','bigint','smallint','tinyint')\n  )\n  BEGIN\n    SET @has_issue = 1;\n    SELECT\n      kcu_child.TABLE_SCHEMA + '.' + kcu_child.TABLE_NAME AS table_name,\n      kcu_child.COLUMN_NAME AS column_name,\n      'Foreign key column ''' + kcu_child.COLUMN_NAME + ''' uses non-integer type ''' + c_child.DATA_TYPE + '''. Keys should be integer-based for consistency and join performance.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\n    FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS fk\n    JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu_child\n      ON fk.CONSTRAINT_NAME = kcu_child.CONSTRAINT_NAME\n    JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu_parent\n      ON fk.UNIQUE_CONSTRAINT_NAME = kcu_parent.CONSTRAINT_NAME\n         AND kcu_child.ORDINAL_POSITION = kcu_parent.ORDINAL_POSITION\n    JOIN INFORMATION_SCHEMA.COLUMNS c_child\n      ON kcu_child.TABLE_SCHEMA = c_child.TABLE_SCHEMA\n         AND kcu_child.TABLE_NAME   = c_child.TABLE_NAME\n         AND kcu_child.COLUMN_NAME  = c_child.COLUMN_NAME\n    JOIN INFORMATION_SCHEMA.COLUMNS c_parent\n      ON kcu_parent.TABLE_SCHEMA = c_parent.TABLE_SCHEMA\n         AND kcu_parent.TABLE_NAME   = c_parent.TABLE_NAME\n         AND kcu_parent.COLUMN_NAME  = c_parent.COLUMN_NAME\n    WHERE c_child.DATA_TYPE NOT IN ('int','bigint','smallint','tinyint')\n       OR c_parent.DATA_TYPE NOT IN ('int','bigint','smallint','tinyint');\n  END\n  ELSE\n  BEGIN\n    SELECT\n      NULL AS table_name,\n      NULL AS column_name,\n      'All foreign key columns are integer-based. This ensures efficient joins and consistent key domains across tables.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result;\n  END\nEND\nELSE\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'No foreign keys defined in the database.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result;\nEND",
      "recommendation": "Convert foreign key columns and their referenced parent columns to integer types. Integer keys improve join performance and reduce storage overhead.",
      "status": "true",
      "severity": 2,
      "content": "query",
      "level": "schema"
    },
    {
      "id": "RL015",
      "category": "Maintainability",
      "description": "Detect invalid name characters (ASCII < 32) in table/column names.",
      "sql_query": "DECLARE @has_issue BIT = 0;\n\nIF EXISTS (\n  SELECT 1 FROM INFORMATION_SCHEMA.COLUMNS WHERE COLUMN_NAME LIKE '%[' + CHAR(0) + '-' + CHAR(31) + ']%'\n  UNION ALL\n  SELECT 1 FROM INFORMATION_SCHEMA.TABLES  WHERE TABLE_NAME  LIKE '%[' + CHAR(0) + '-' + CHAR(31) + ']%'\n)\nBEGIN\n  SET @has_issue = 1;\n  SELECT\n    TABLE_NAME  AS table_name,\n    COLUMN_NAME AS column_name,\n    'Name contains control characters (ASCII < 32). Such characters can cause tooling failures and confusion; rename to remove them.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\n  FROM INFORMATION_SCHEMA.COLUMNS\n  WHERE COLUMN_NAME LIKE '%[' + CHAR(0) + '-' + CHAR(31) + ']%'\n  UNION ALL\n  SELECT\n    TABLE_SCHEMA + '.' + TABLE_NAME AS table_name,\n    NULL       AS column_name,\n    'Table name contains control characters (ASCII < 32). This can break scripts and metadata tools; rename accordingly.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\n  FROM INFORMATION_SCHEMA.TABLES\n  WHERE TABLE_NAME LIKE '%[' + CHAR(0) + '-' + CHAR(31) + ']%';\nEND\nELSE\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'No invalid control characters found in table or column names. Naming is clean and tooling-safe.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result;\nEND",
      "recommendation": "Remove control characters from table and column names. Use only printable characters to ensure compatibility with scripts and tools.",
      "status": "true",
      "severity": 3,
      "content": "query",
      "level": "table"
    },
    {
      "id": "RL016",
      "category": "Maintainability",
      "description": "Check if table/column names begin with uppercase letters.",
      "sql_query": "DECLARE @has_issue BIT = 0;\n\nIF EXISTS (\n  SELECT 1 FROM INFORMATION_SCHEMA.TABLES  WHERE TABLE_SCHEMA NOT IN ('sys', 'INFORMATION_SCHEMA', 'queryinsights') AND LEFT(TABLE_NAME,1) COLLATE Latin1_General_CS_AS NOT LIKE '[A-Z]'\n  UNION ALL\n  SELECT 1 FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA NOT IN ('sys', 'INFORMATION_SCHEMA', 'queryinsights') AND LEFT(COLUMN_NAME,1) COLLATE Latin1_General_CS_AS NOT LIKE '[A-Z]'\n)\nBEGIN\n  SET @has_issue = 1;\n  SELECT\n    TABLE_SCHEMA + '.' + TABLE_NAME AS table_name,\n    NULL       AS column_name,\n    'Table name ''' + TABLE_NAME + ''' begins with a lowercase letter. Consistent capitalization improves readability and conventions enforcement.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\n  FROM INFORMATION_SCHEMA.TABLES\n  WHERE TABLE_SCHEMA NOT IN ('sys', 'INFORMATION_SCHEMA', 'queryinsights') AND LEFT(TABLE_NAME,1) COLLATE Latin1_General_CS_AS NOT LIKE '[A-Z]'\n  UNION ALL\n  SELECT\n    TABLE_NAME  AS table_name,\n    COLUMN_NAME AS column_name,\n    'Column name ''' + COLUMN_NAME + ''' begins with a lowercase letter. Follow naming conventions by starting identifiers with uppercase.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\n  FROM INFORMATION_SCHEMA.COLUMNS\n  WHERE TABLE_SCHEMA NOT IN ('sys', 'INFORMATION_SCHEMA', 'queryinsights') AND LEFT(COLUMN_NAME,1) COLLATE Latin1_General_CS_AS NOT LIKE '[A-Z]';\nEND\nELSE\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'All table and column names begin with uppercase letters. This consistent style aids readability and convention compliance.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result;\nEND",
      "recommendation": "Rename tables and columns to start with an uppercase letter. Consistent naming conventions simplify maintenance and reduce errors.",
      "status": "true",
      "severity": 3,
      "content": "query",
      "level": "table"
    },
    {
      "id": "RL017",
      "category": "Performance",
      "description": "Detect columns with very long defined length and high cardinality, possibly over-provisioned.",
      "sql_query": "DECLARE @has_issue BIT = 0;\n\nIF EXISTS (\n  SELECT 1\n  FROM INFORMATION_SCHEMA.COLUMNS\n  WHERE TABLE_SCHEMA NOT IN ('sys', 'INFORMATION_SCHEMA', 'queryinsights')\n    AND DATA_TYPE IN ('char','varchar','nchar','nvarchar')\n    AND CHARACTER_MAXIMUM_LENGTH > 100\n)\nBEGIN\n  SET @has_issue = 1;\n  SELECT\n    TABLE_NAME  AS table_name,\n    COLUMN_NAME AS column_name,\n    'Column ''' + COLUMN_NAME + ''' in table ''' + TABLE_NAME + ''' has defined length ' + CAST(CHARACTER_MAXIMUM_LENGTH AS VARCHAR(10)) + '. Oversized types waste space; evaluate actual data lengths.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\n  FROM INFORMATION_SCHEMA.COLUMNS\n  WHERE TABLE_SCHEMA NOT IN ('sys', 'INFORMATION_SCHEMA', 'queryinsights')\n    AND DATA_TYPE IN ('char','varchar','nchar','nvarchar')\n    AND CHARACTER_MAXIMUM_LENGTH > 100;\nEND\nELSE\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'No oversized columns found in dbo schema. Defined lengths align with expected data sizes, optimizing storage usage.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result;\nEND",
      "recommendation": "Adjust column lengths to match typical data sizes. Reducing over-provisioned types can save storage and improve I/O performance.",
      "status": "true",
      "severity": 2,
      "content": "query",
      "level": "table"
    },
    {
      "id": "RL018",
      "category": "Performance",
      "description": "Keep statistics up-to-date so the query optimizer can select efficient execution plans.",
      "sql_query": "DECLARE @has_issue BIT = 0;\n\nIF EXISTS (\n  SELECT 1\n  FROM sys.stats s\n  JOIN sys.tables t ON s.object_id = t.object_id\n  WHERE s.auto_created = 1\n  GROUP BY t.schema_id, t.name\n  HAVING MAX(DATEDIFF(day, STATS_DATE(s.object_id, s.stats_id), GETDATE())) > 30\n)\nBEGIN\n  SET @has_issue = 1;\n  SELECT\n    SCHEMA_NAME(t.schema_id) + '.' + t.name AS table_name,\n    NULL   AS column_name,\n    'Table ''' + t.name + ''' has outdated statistics: ' + CAST(MAX(DATEDIFF(day, STATS_DATE(s.object_id, s.stats_id), GETDATE())) AS VARCHAR(5)) + ' days old. Stale stats can lead to suboptimal query plans; update stats regularly.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\n  FROM sys.stats s\n  JOIN sys.tables t ON s.object_id = t.object_id\n  WHERE s.auto_created = 1\n  GROUP BY t.schema_id, t.name\n  HAVING MAX(DATEDIFF(day, STATS_DATE(s.object_id, s.stats_id), GETDATE())) > 30;\nEND\nELSE\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'All tables have statistics updated within the last 30 days. This ensures the optimizer has current distribution data for efficient plans.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result;\nEND",
      "recommendation": "Enable AUTO_UPDATE_STATISTICS or schedule regular UPDATE STATISTICS jobs. Keeping stats current avoids costly full scans and poor plan choices.",
      "remediation_template": "UPDATE STATISTICS {table_name}",
      "status": "true",
      "severity": 2,
      "content": "query",
      "level": "table"
    },
    {
      "id": "RL019",
      "category": "Performance",
      "description": "Enable asynchronous statistics updates for large or heavily updated tables to avoid blocking queries during stats refresh.",
      "sql_query": "DECLARE @is_async BIT = (SELECT is_auto_update_stats_async_on FROM sys.databases WHERE name = DB_NAME());\n\nIF @is_async = 0\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'AUTO_UPDATE_STATISTICS_ASYNC is disabled. For large tables, synchronous stats updates can block queries; consider enabling async stats.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result;\nEND\nELSE\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'AUTO_UPDATE_STATISTICS_ASYNC is enabled. This allows statistics updates to occur without blocking user queries, improving concurrency.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result;\nEND",
      "recommendation": "Use `ALTER DATABASE CURRENT SET AUTO_UPDATE_STATISTICS_ASYNC ON` for large or OLTP environments. Asynchronous updates reduce query blocking during stats maintenance.",
      "status": "false",
      "fabric_note": "Disabled: Duplicate of RL113. Fabric manages statistics automatically.",
      "severity": 2,
      "content": "query",
      "level": "database"
    },
    {
      "id": "RL020",
      "category": "Performance",
      "description": "Choose smallest suitable data types (e.g., INT vs BIGINT, VARCHAR(50) vs VARCHAR(255)) to reduce memory and I/O.",
      "sql_query": "DECLARE @has_issue BIT = 0;\n\nIF EXISTS (\n  SELECT 1\n  FROM sys.tables t\n  JOIN sys.columns c ON t.object_id = c.object_id\n  WHERE (TYPE_NAME(c.user_type_id) IN ('nvarchar','varchar') AND c.max_length > 255)\n     OR (TYPE_NAME(c.user_type_id) = 'decimal' AND c.precision > 18)\n)\nBEGIN\n  SET @has_issue = 1;\n  SELECT\n    SCHEMA_NAME(t.schema_id) + '.' + t.name AS table_name,\n    c.name      AS column_name,\n    CASE\n      WHEN TYPE_NAME(c.user_type_id) IN ('nvarchar','varchar') AND c.max_length > 255\n        THEN 'Oversized string column: ' + TYPE_NAME(c.user_type_id) + '(' + CAST(c.max_length AS VARCHAR(10)) + ')' \n      WHEN TYPE_NAME(c.user_type_id) = 'decimal' AND c.precision > 18\n        THEN 'Oversized decimal column: ' + CAST(c.precision AS VARCHAR(2)) + ',' + CAST(c.scale AS VARCHAR(2))\n      ELSE 'Oversized column: ' + TYPE_NAME(c.user_type_id)\n    END\n    + CHAR(10)+CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\n  FROM sys.tables t\n  JOIN sys.columns c ON t.object_id = c.object_id\n  WHERE (TYPE_NAME(c.user_type_id) IN ('nvarchar','varchar') AND c.max_length > 255)\n     OR (TYPE_NAME(c.user_type_id) = 'decimal' AND c.precision > 18);\nEND\nELSE\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'No oversized columns found. All columns use appropriately sized types, optimizing storage and I/O.'\n    + CHAR(10)+CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result;\nEND",
      "recommendation": "Review columns above and ensure they match actual data needs. Smaller types improve compression and query performance.",
      "status": "true",
      "severity": 3,
      "content": "query",
      "level": "table"
    },
    {
      "id": "RL021",
      "category": "Security",
      "description": "Limit the number of high-privilege accounts (e.g., db_owner). Regularly review membership.",
      "sql_query": "DECLARE @has_issue BIT = 0;\n\nIF EXISTS (\n  SELECT 1\n  FROM sys.database_role_members rm\n  JOIN sys.database_principals p ON rm.member_principal_id = p.principal_id\n  JOIN sys.database_principals r ON rm.role_principal_id   = r.principal_id\n  WHERE r.name = 'db_owner'\n)\nBEGIN\n  SET @has_issue = 1;\n  SELECT\n    NULL       AS table_name,\n    p.name     AS column_name,\n    'User ''' + p.name + ''' has db_owner privileges. High privilege accounts increase risk; minimize membership.'\n    + CHAR(10)+CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\n  FROM sys.database_role_members rm\n  JOIN sys.database_principals p ON rm.member_principal_id = p.principal_id\n  JOIN sys.database_principals r ON rm.role_principal_id   = r.principal_id\n  WHERE r.name = 'db_owner';\nEND\nELSE\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'No users with db_owner privileges found. High-privilege membership is minimal, reducing security risk.'\n    + CHAR(10)+CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result;\nEND",
      "recommendation": "If many users appear in db_owner, reduce privileges. Keep admin roles minimal to reduce risk.",
      "status": "true",
      "severity": 1,
      "content": "query",
      "level": "database"
    },
    {
      "id": "RL023",
      "category": "Security",
      "description": "Implement Row-Level Security (RLS) if you must restrict which rows certain users can see.",
      "sql_query": "DECLARE @policies INT = (SELECT COUNT(*) FROM sys.security_policies WHERE [type] = 1);\n\nIF @policies = 0\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'No row-level security policies found. Consider adding RLS to protect sensitive data at row granularity.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result;\nEND\nELSE\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'Row-level security policies found: ' + CAST(@policies AS VARCHAR) + '. Ensure predicates correctly enforce access rules.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result;\nEND",
      "recommendation": "If rls_policies=0 and data requires row-level isolation, add a security policy and predicate function for filtering.",
      "status": "true",
      "severity": 1,
      "content": "query",
      "level": "database"
    },
    {
      "id": "RL024",
      "category": "Maintainability",
      "description": "Use consistent table naming conventions (no reserved words, minimal special chars).",
      "sql_query": "IF EXISTS (SELECT 1 FROM sys.tables WHERE name LIKE '% %' OR name LIKE '%[^0-9A-Za-z_]%')\nBEGIN\n  SELECT\n    name AS table_name,\n    NULL AS column_name,\n    'Table name contains special characters or spaces. Use only letters, numbers, and underscores.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\n  FROM sys.tables\n  WHERE name LIKE '% %' OR name LIKE '%[^0-9A-Za-z_]%';\nEND\nELSE\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'All table names follow naming conventions. No spaces or special characters found.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result;\nEND",
      "recommendation": "Adopt a clear standard (e.g., PascalCase or snake_case). Avoid spaces, punctuation, or reserved keywords in table names.",
      "status": "true",
      "severity": 3,
      "content": "query",
      "level": "table"
    },
    {
      "id": "RL025",
      "category": "Maintainability",
      "description": "Avoid extremely wide tables (50+ columns). Breaking out logically separate data can simplify usage and maintenance.",
      "sql_query": "IF EXISTS (\n  SELECT 1\n  FROM sys.tables t\n  JOIN sys.columns c ON t.object_id = c.object_id\n  GROUP BY t.schema_id, t.name\n  HAVING COUNT(c.column_id) > 50\n)\nBEGIN\n  SELECT\n    SCHEMA_NAME(t.schema_id) + '.' + t.name AS table_name,\n    NULL   AS column_name,\n    'Table has ' + CAST(COUNT(c.column_id) AS VARCHAR) + ' columns – consider splitting if possible.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\n  FROM sys.tables t\n  JOIN sys.columns c ON t.object_id = c.object_id\n  GROUP BY t.schema_id, t.name\n  HAVING COUNT(c.column_id) > 50;\nEND\nELSE\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'No extremely wide tables found (all have ≤50 columns).' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result;\nEND",
      "recommendation": "If a table has 50+ columns, evaluate whether breaking it into related tables improves clarity and performance.",
      "status": "true",
      "severity": 2,
      "content": "query",
      "level": "table"
    },
    {
      "id": "RL026",
      "category": "Maintainability",
      "description": "Define foreign key constraints where logical parent-child relationships exist, to document and enforce referential integrity.",
      "sql_query": "IF EXISTS (\n  SELECT 1\n  FROM sys.tables t\n  LEFT JOIN sys.foreign_keys fk ON t.object_id = fk.parent_object_id\n  WHERE t.is_ms_shipped = 0\n  GROUP BY t.schema_id, t.name\n  HAVING COUNT(fk.object_id) = 0\n)\nBEGIN\n  SELECT\n    SCHEMA_NAME(t.schema_id) + '.' + t.name AS table_name,\n    NULL   AS column_name,\n    'Table lacks foreign key relationships – consider adding FKs to enforce integrity.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\n  FROM sys.tables t\n  LEFT JOIN sys.foreign_keys fk ON t.object_id = fk.parent_object_id\n  WHERE t.is_ms_shipped = 0\n  GROUP BY t.schema_id, t.name\n  HAVING COUNT(fk.object_id) = 0;\nEND\nELSE\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'All user tables have at least one foreign key relationship, ensuring documented referential integrity.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result;\nEND",
      "recommendation": "For tables referencing others, add foreign key constraints. Even if enforcement is disabled, it documents relationships clearly.",
      "status": "true",
      "severity": 2,
      "content": "query",
      "level": "table"
    },
    {
      "id": "RL027",
      "category": "Maintainability",
      "description": "Avoid storing large unstructured data (e.g. images, PDF) in tables. Use external storage if possible.",
      "sql_query": "IF EXISTS (\n  SELECT 1\n  FROM sys.tables t\n  JOIN sys.columns c ON t.object_id = c.object_id\n  JOIN sys.types typ ON c.user_type_id = typ.user_type_id\n  WHERE typ.name IN ('varbinary','varchar','nvarchar')\n    AND (c.max_length = -1 OR c.max_length > 8000)\n)\nBEGIN\n  SELECT\n    SCHEMA_NAME(t.schema_id) + '.' + t.name AS table_name,\n    c.name AS column_name,\n    'Column ''' + c.name + ''' might contain large unstructured data. Consider external storage for BLOBs.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\n  FROM sys.tables t\n  JOIN sys.columns c ON t.object_id = c.object_id\n  JOIN sys.types typ ON c.user_type_id = typ.user_type_id\n  WHERE typ.name IN ('varbinary','varchar','nvarchar')\n    AND (c.max_length = -1 OR c.max_length > 8000);\nEND\nELSE\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'No large unstructured data columns found. BLOBs are not stored directly in tables.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result;\nEND",
      "recommendation": "Use a data lake or blob storage for large BLOBs. Keep the relational database focused on structured data.",
      "status": "true",
      "severity": 2,
      "content": "query",
      "level": "table"
    },
    {
      "id": "RL028",
      "category": "Data Quality",
      "description": "Check for potential duplicate values in important identifier columns that aren't enforced by constraints.",
      "sql_query": "DECLARE @sql NVARCHAR(MAX) = '';\n\nSELECT @sql = @sql +\n  'SELECT ''' + TABLE_NAME + ''' AS table_name, ''' + COLUMN_NAME + ''' AS column_name, ''Column has duplicate values but no unique constraint. Consider adding a unique index or constraint.'' + CHAR(10)+CHAR(10)+''Indicator: Anomaly - ERR_1001'' AS result FROM (SELECT COUNT(*) AS total_rows, COUNT(DISTINCT ' + QUOTENAME(COLUMN_NAME) + ') AS distinct_values FROM ' + QUOTENAME(TABLE_SCHEMA) + '.' + QUOTENAME(TABLE_NAME) + ') t WHERE total_rows <> distinct_values UNION ALL '\nFROM INFORMATION_SCHEMA.COLUMNS\nWHERE TABLE_SCHEMA NOT IN ('sys', 'INFORMATION_SCHEMA', 'queryinsights')\n  AND COLUMN_NAME LIKE '%id'\n  AND COLUMN_NAME<>'id'\n  AND DATA_TYPE NOT IN ('image','text','ntext','xml','geography','geometry')\n  AND (CHARACTER_MAXIMUM_LENGTH IS NULL OR CHARACTER_MAXIMUM_LENGTH<=450);\n\nIF LEN(@sql)>0\nBEGIN\n    SET @sql = LEFT(@sql, LEN(@sql)-11);\n    SET @sql = @sql + ' IF @@ROWCOUNT = 0 SELECT NULL AS table_name, NULL AS column_name, ''No columns with potential duplicate values found. All identifier columns are unique or properly constrained.'' + CHAR(10)+CHAR(10) + ''Indicator: Optimized - OPT_2001'' AS result;';\n    EXEC sp_executesql @sql;\nEND\nELSE\nBEGIN\n    SELECT\n        NULL AS table_name,\n        NULL AS column_name,\n        'No identifier columns found to check for duplicates.'\n        + CHAR(10)+CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result;\nEND",
      "recommendation": "If these columns should be unique, add unique constraints or indexes to enforce this. Otherwise, review duplicates to ensure they are legitimate.",
      "status": "true",
      "severity": 2,
      "content": "query",
      "level": "table"
    },
    {
      "id": "RL029",
      "category": "Maintainability",
      "description": "Identify tables with very low row counts that might be unused or underutilized.",
      "sql_query": "IF EXISTS (SELECT 1 FROM sys.tables t JOIN sys.partitions p ON t.object_id = p.object_id WHERE p.index_id IN (0,1) AND t.is_ms_shipped = 0 GROUP BY t.name HAVING SUM(p.rows) < 10)\nBEGIN\n    SELECT\n        SCHEMA_NAME(t.schema_id) + '.' + t.name AS table_name,\n        NULL AS column_name,\n        'Table has very few rows (Row Count: ' + CAST(SUM(p.rows) AS VARCHAR(10)) + '). Such low volume may indicate a staging, test, or unused table. Verify its purpose and consider consolidation or removal if it is no longer needed.'\n        + CHAR(10)+CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\n    FROM sys.tables t\n    JOIN sys.partitions p ON t.object_id = p.object_id\n    WHERE p.index_id IN (0,1) AND t.is_ms_shipped = 0\n    GROUP BY t.schema_id, t.name\n    HAVING SUM(p.rows) < 10\n    ORDER BY SUM(p.rows);\nEND\nELSE\nBEGIN\n    SELECT\n        NULL AS table_name,\n        NULL AS column_name,\n        'No tables with few rows found. All tables contain 10 or more rows and appear to be actively used. No further action is needed.'\n        + CHAR(10)+CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result;\nEND",
      "recommendation": "Tables with very few rows might indicate test data, incomplete implementation, or obsolete features. Check if they are necessary.",
      "status": "true",
      "severity": 3,
      "content": "query",
      "level": "table"
    },
    {
      "id": "RL031",
      "category": "Performance",
      "description": "Identify any computed columns which might affect query performance or storage.",
      "sql_query": "IF EXISTS (SELECT 1 FROM sys.computed_columns c JOIN sys.tables t ON c.object_id = t.object_id WHERE t.is_ms_shipped = 0)\nBEGIN\n    SELECT\n        t.name AS table_name,\n        c.name AS column_name,\n        'Column is computed (persisted = ' + CAST(COLUMNPROPERTY(c.object_id, c.name, 'IsPersisted') AS VARCHAR(5)) + '). Non-persisted computed columns are calculated at runtime and may degrade performance. Consider persisting this column or moving the calculation to an ETL process.'\n        + CHAR(10)+CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\n    FROM sys.computed_columns c\n    JOIN sys.tables t ON c.object_id = t.object_id\n    WHERE t.is_ms_shipped = 0;\nEND\nELSE\nBEGIN\n    SELECT\n        NULL AS table_name,\n        NULL AS column_name,\n        'No computed columns found. All columns are physically stored, ensuring predictable performance. No action is required.'\n        + CHAR(10)+CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result;\nEND",
      "recommendation": "Review computed columns and ensure they are persisted if frequently queried. Non-persisted computed columns can cause performance overhead.",
      "status": "false",
      "fabric_note": "Disabled: Computed columns are not supported in Fabric Warehouse.",
      "severity": 2,
      "content": "query",
      "level": "column"
    },
    {
      "id": "RL032",
      "category": "Data Quality",
      "description": "Check for tables with inconsistent date formats across related columns.",
      "sql_query": "IF EXISTS (SELECT 1 FROM sys.tables t JOIN sys.columns c ON t.object_id = c.object_id JOIN sys.types ty ON c.user_type_id = ty.user_type_id WHERE t.is_ms_shipped = 0 AND ty.name IN ('date','datetime','datetime2','smalldatetime','datetimeoffset') GROUP BY t.schema_id, t.name, t.object_id HAVING COUNT(DISTINCT ty.name) > 1)\nBEGIN\n    SELECT\n        SCHEMA_NAME(t.schema_id) + '.' + t.name AS table_name,\n        c.name AS column_name,\n        'Column ''' + c.name + ''' uses type ''' + ty.name + ''' but table has mixed date/time types. Mixing date, datetime, smalldatetime, and datetimeoffset can cause conversion errors. Standardize on a single type.'\n        + CHAR(10)+CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\n    FROM sys.tables t\n    JOIN sys.columns c ON t.object_id = c.object_id\n    JOIN sys.types ty ON c.user_type_id = ty.user_type_id\n    WHERE t.is_ms_shipped = 0\n      AND ty.name IN ('date','datetime','datetime2','smalldatetime','datetimeoffset')\n      AND t.object_id IN (\n        SELECT t2.object_id\n        FROM sys.tables t2\n        JOIN sys.columns c2 ON t2.object_id = c2.object_id\n        JOIN sys.types ty2 ON c2.user_type_id = ty2.user_type_id\n        WHERE t2.is_ms_shipped = 0\n          AND ty2.name IN ('date','datetime','datetime2','smalldatetime','datetimeoffset')\n        GROUP BY t2.object_id\n        HAVING COUNT(DISTINCT ty2.name) > 1\n      )\n    ORDER BY t.name, c.name;\nEND\nELSE\nBEGIN\n    SELECT\n        NULL AS table_name,\n        NULL AS column_name,\n        'No tables with mixed date types found. Each table uses a consistent date/time type, preventing conversion issues and subtle bugs. Schema is well standardized.'\n        + CHAR(10)+CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result;\nEND",
      "recommendation": "Standardize on a single date/time type within a table. Mixing datetime, datetime2, date etc. can lead to confusion and subtle bugs.",
      "status": "true",
      "severity": 2,
      "content": "query",
      "level": "table"
    },
    {
      "id": "RL033",
      "category": "Data Quality",
      "description": "Detect string columns that could be candidates for conversion to more efficient data types.",
      "sql_query": "IF EXISTS (\n  SELECT 1 FROM INFORMATION_SCHEMA.COLUMNS\n  WHERE TABLE_SCHEMA NOT IN ('sys', 'INFORMATION_SCHEMA', 'queryinsights')\n    AND DATA_TYPE IN ('varchar', 'nvarchar', 'char', 'nchar')\n    AND CHARACTER_MAXIMUM_LENGTH <= 20\n    AND (COLUMN_NAME LIKE '%id' OR COLUMN_NAME LIKE '%num%' OR COLUMN_NAME LIKE '%code%' OR COLUMN_NAME LIKE '%amount%')\n    AND COLUMN_NAME NOT LIKE '%guid%'\n    AND COLUMN_NAME NOT LIKE '%uuid%'\n)\nBEGIN\n  SELECT\n    TABLE_SCHEMA + '.' + TABLE_NAME AS table_name,\n    COLUMN_NAME AS column_name,\n    'String column [' + COLUMN_NAME + '] in table [' + TABLE_NAME + '] (type: ' + DATA_TYPE + '(' + CAST(COALESCE(CHARACTER_MAXIMUM_LENGTH, 0) AS VARCHAR(10)) + ')) has a short length and numeric-like name. Review if it stores only numeric data and could be converted to INT/BIGINT.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\n  FROM INFORMATION_SCHEMA.COLUMNS\n  WHERE TABLE_SCHEMA NOT IN ('sys', 'INFORMATION_SCHEMA', 'queryinsights')\n    AND DATA_TYPE IN ('varchar', 'nvarchar', 'char', 'nchar')\n    AND CHARACTER_MAXIMUM_LENGTH <= 20\n    AND (COLUMN_NAME LIKE '%id' OR COLUMN_NAME LIKE '%num%' OR COLUMN_NAME LIKE '%code%' OR COLUMN_NAME LIKE '%amount%')\n    AND COLUMN_NAME NOT LIKE '%guid%'\n    AND COLUMN_NAME NOT LIKE '%uuid%';\nEND\nELSE\nBEGIN\n  SELECT NULL AS table_name, NULL AS column_name, 'No short string columns with numeric-like names found.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result;\nEND",
      "recommendation": "These string columns contain only numeric values and could be converted to more efficient and appropriate numeric data types. For digits up to 9 characters, use INT; for larger numbers up to 19 digits, use BIGINT; for numbers with decimal places or greater precision, use DECIMAL with appropriate precision and scale. Converting to numeric types will improve storage efficiency, query performance, and enable proper numeric operations.",
      "status": "true",
      "severity": 3,
      "content": "query",
      "level": "schema"
    },
    {
      "id": "RL034",
      "category": "Data Quality",
      "description": "Check for columns storing JSON data that might be better structured as relational tables.",
      "sql_query": "DECLARE @sql NVARCHAR(MAX) = '';\nDECLARE @columnCount INT = 0;\n\nSELECT @columnCount = COUNT(*) \nFROM INFORMATION_SCHEMA.COLUMNS\nWHERE TABLE_SCHEMA NOT IN ('sys', 'INFORMATION_SCHEMA', 'queryinsights') AND DATA_TYPE IN ('varchar', 'nvarchar', 'char', 'nchar');\n\nIF @columnCount = 0\nBEGIN\n    SELECT NULL AS table_name, NULL AS column_name, 'No string columns to check for JSON data. Database contains no VARCHAR/NVARCHAR columns.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result;\nEND\nELSE\nBEGIN\n    SELECT @sql = @sql + 'SELECT ''' + TABLE_NAME + ''' AS table_name, ''' + COLUMN_NAME + ''' AS column_name, ''Column likely contains JSON data'' + CHAR(10) + CHAR(10) + ''Indicator: Anomaly - ERR_1001'' AS result FROM ' + QUOTENAME(TABLE_SCHEMA) + '.' + QUOTENAME(TABLE_NAME) + ' WHERE TRY_CAST(' + QUOTENAME(COLUMN_NAME) + ' AS NVARCHAR(MAX)) IS NOT NULL AND ISJSON(' + QUOTENAME(COLUMN_NAME) + ') = 1 HAVING COUNT(*) > 0 UNION ALL '\n    FROM INFORMATION_SCHEMA.COLUMNS\n    WHERE TABLE_SCHEMA NOT IN ('sys', 'INFORMATION_SCHEMA', 'queryinsights') AND DATA_TYPE IN ('varchar', 'nvarchar', 'char', 'nchar');\n\n    IF LEN(@sql) > 0\n    BEGIN\n        SET @sql = LEFT(@sql, LEN(@sql) - 10);\n        SET @sql = 'IF EXISTS (' + @sql + ')\n                  BEGIN\n                      ' + @sql + '\n                  END\n                  ELSE\n                  BEGIN\n                      SELECT NULL AS table_name, NULL AS column_name, ''No valid JSON data was found in any of the ' + CAST(@columnCount AS VARCHAR(10)) + ' columns scanned. Each column was checked individually, but none contained properly formatted JSON. Possible reasons include absence of JSON, malformed data, or unsupported data types.'' + CHAR(10) + CHAR(10) + ''Indicator: Optimized - OPT_2001'' AS result;\n                  END';\n        EXEC sp_executesql @sql;\n    END\n    ELSE\n    BEGIN\n        SELECT NULL AS table_name, NULL AS column_name, 'No string columns to check for JSON data.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result;\n    END\nEND",
      "recommendation": "Columns storing JSON data might be better modeled as separate tables or using JSON_VALUE indexes for better query performance. Consider normalizing frequently accessed JSON properties into dedicated columns.",
      "status": "true",
      "severity": 2,
      "content": "query",
      "level": "schema"
    },
    {
      "id": "RL035",
      "category": "Security",
      "description": "Detect tables with sensitive information but without classification labels or tags.",
      "sql_query": "DECLARE @sensitivePatternsCount INT = 18;\n\nWITH SensitiveColumns AS (\n    SELECT \n        SCHEMA_NAME(t.schema_id) + '.' + t.name AS table_name,\n        COUNT(DISTINCT c.name) AS sensitive_column_count,\n        STRING_AGG(c.name, ', ') AS sensitive_columns_found\n    FROM sys.tables t\n    JOIN sys.columns c ON c.object_id = t.object_id\n    WHERE t.is_ms_shipped = 0\n    AND (\n        c.name LIKE '%credit%' OR c.name LIKE '%card%' OR c.name LIKE '%ssn%' \n        OR c.name LIKE '%password%' OR c.name LIKE '%pass%' OR c.name LIKE '%account%' \n        OR c.name LIKE '%secret%' OR c.name LIKE '%key%' OR c.name LIKE '%phone%'\n        OR c.name LIKE '%mobile%' OR c.name LIKE '%email%' OR c.name LIKE '%mail%'  \n        OR c.name LIKE '%BIC%' OR c.name LIKE '%IBAN%' OR c.name LIKE '%SWIFT%'\n        OR c.name LIKE '%license%' OR c.name LIKE '%national%id%' OR c.name LIKE '%tax%id%'\n    )\n    GROUP BY t.schema_id, t.name, t.object_id\n)\nSELECT \n    sc.table_name,\n    NULL AS column_name,\n    CASE \n        WHEN sc.table_name IS NULL THEN 'No tables containing any of the ' + CAST(@sensitivePatternsCount AS VARCHAR) + ' types of sensitive columns found' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001'\n        ELSE 'Table likely has sensitive data but no classification: Found ' + \n             CAST(sc.sensitive_column_count AS VARCHAR) + ' sensitive columns (' + \n             sc.sensitive_columns_found + ')' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001'\n    END AS result\nFROM SensitiveColumns sc\nWHERE NOT EXISTS (\n    SELECT 1 \n    FROM sys.sensitivity_classifications ssc \n    JOIN sys.tables st ON ssc.major_id = st.object_id\n    WHERE st.name = sc.table_name\n)\nUNION ALL\nSELECT \n    NULL AS table_name,\n    NULL AS column_name,\n    'No tables with unclassified sensitive information found based on ' + CAST(@sensitivePatternsCount AS VARCHAR) + \n    ' sensitive column patterns (credit, card, ssn, password, pass, account, secret, key, phone, mobile, email, mail, BIC, IBAN, SWIFT, license, national id, tax id)' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result\nWHERE NOT EXISTS (SELECT 1 FROM SensitiveColumns)\nUNION ALL\nSELECT \n    NULL AS table_name,\n    NULL AS column_name,\n    'All tables with sensitive columns are properly classified using sensitivity classifications. Checked ' + CAST(@sensitivePatternsCount AS VARCHAR) + ' sensitive column patterns.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result\nWHERE EXISTS (SELECT 1 FROM SensitiveColumns)\nAND NOT EXISTS (\n    SELECT 1 FROM SensitiveColumns sc2\n    WHERE NOT EXISTS (\n        SELECT 1 FROM sys.sensitivity_classifications ssc\n        JOIN sys.tables st ON ssc.major_id = st.object_id\n        WHERE st.name = sc2.table_name\n    )\n);",
      "recommendation": "Use the ADD SENSITIVITY CLASSIFICATION command to properly tag sensitive data for compliance and security purposes. Sensitive data should be identified, classified and protected according to regulatory requirements.",
      "status": "true",
      "severity": 1,
      "content": "query",
      "level": "table"
    },
    {
      "id": "RL036",
      "category": "Data Quality",
      "description": "Detect tables with columns that likely store delimited lists instead of proper normalized relationships.",
      "sql_query": "DECLARE @sql NVARCHAR(MAX) = '';\n\nSELECT @sql = @sql + 'SELECT ''' + TABLE_NAME + ''' AS table_name, ''' + COLUMN_NAME + ''' AS column_name, ''Column likely contains delimited values in [' + COLUMN_NAME + ']'' + CHAR(10) + CHAR(10) + ''Indicator: Anomaly - ERR_1001'' AS result FROM ' + QUOTENAME(TABLE_SCHEMA) + '.' + QUOTENAME(TABLE_NAME) + ' WHERE ' + QUOTENAME(COLUMN_NAME) + ' LIKE ''%,%'' AND ' + QUOTENAME(COLUMN_NAME) + ' NOT LIKE ''%,%,%,%,%'' HAVING COUNT(*) > 10 UNION ALL ' FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA NOT IN ('sys', 'INFORMATION_SCHEMA', 'queryinsights') AND DATA_TYPE IN ('varchar', 'nvarchar', 'char', 'nchar');\n\nIF LEN(@sql) > 0\nBEGIN\n    SET @sql = LEFT(@sql, LEN(@sql) - 10);\n    SET @sql = @sql + ' IF @@ROWCOUNT = 0 SELECT NULL AS table_name, NULL AS column_name, ''No columns with delimited values found.'' + CHAR(10) + CHAR(10) + ''Indicator: Optimized - OPT_2001'' AS result;';\n    EXEC sp_executesql @sql;\nEND\nELSE\nBEGIN\n    SELECT NULL AS table_name, NULL AS column_name, 'No string columns found to check for delimited values.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result;\nEND",
      "recommendation": "Columns that store comma-separated values indicate poor normalization. Consider creating proper lookup tables and relationships instead of delimited lists.",
      "status": "true",
      "severity": 2,
      "content": "query",
      "level": "schema"
    },
    {
      "id": "RL037",
      "category": "Data Quality",
      "description": "Check if tables have standard audit columns (created_at, created_date, updated_at, updated_date, modified_at, modified_date, created_by, updated_by, modified_by).",
      "sql_query": "WITH AuditColumns AS (\n  SELECT column_name\n  FROM (VALUES ('created_at'), ('created_date'), ('updated_at'), ('updated_date'), ('modified_at'), ('modified_date'), ('created_by'), ('updated_by'), ('modified_by')) AS cols(column_name)\n),\nTableColumns AS (\n  SELECT \n    SCHEMA_NAME(t.schema_id) + '.' + t.name AS table_name,\n    ac.column_name,\n    CASE WHEN c.name IS NULL THEN 0 ELSE 1 END AS has_column\n  FROM sys.tables t\n  CROSS JOIN AuditColumns ac\n  LEFT JOIN sys.columns c ON t.object_id = c.object_id AND \n                            (c.name = ac.column_name OR \n                             c.name = REPLACE(ac.column_name, '_', '') OR \n                             c.name = UPPER(ac.column_name))\n  WHERE t.is_ms_shipped = 0\n),\nTableSummary AS (\n  SELECT \n    table_name,\n    SUM(has_column) AS columns_present,\n    COUNT(*) - SUM(has_column) AS columns_missing,\n    STRING_AGG(CASE WHEN has_column = 0 THEN column_name ELSE NULL END, ', ') AS missing_columns\n  FROM TableColumns\n  GROUP BY table_name\n)\nSELECT \n  ts.table_name,\n  NULL AS column_name,\n  CASE \n    WHEN ts.columns_missing = 0 THEN 'All audit columns present'\n    WHEN ts.columns_missing = 9 THEN 'Missing all audit columns: ' + ts.missing_columns\n    ELSE 'Missing ' + CAST(ts.columns_missing AS VARCHAR(2)) + ' audit columns: ' + ts.missing_columns\n  END + CHAR(10) + CHAR(10) + \n  CASE \n    WHEN ts.columns_missing = 0 THEN 'Indicator: Optimized - OPT_2001' \n    ELSE 'Indicator: Anomaly - ERR_1001'\n  END AS result\nFROM TableSummary ts\nUNION ALL\nSELECT \n    NULL AS table_name,\n    NULL AS column_name,\n    'No user tables found in the database. Audit column check is not applicable.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result\nWHERE NOT EXISTS (SELECT 1 FROM sys.tables WHERE is_ms_shipped = 0)\nORDER BY table_name;",
      "recommendation": "Add standard audit columns (created_at/created_date, updated_at/updated_date, modified_at/modified_date, created_by, updated_by, modified_by) to track when and by whom records were created or modified.",
      "remediation_template": "ALTER TABLE {table_name} ADD created_at DATETIME2 NULL, updated_at DATETIME2 NULL, created_by NVARCHAR(128) NULL, updated_by NVARCHAR(128) NULL",
      "status": "true",
      "severity": 2,
      "content": "query",
      "level": "table"
    },
    {
      "id": "RL110",
      "category": "Performance",
      "description": "AUTO_CLOSE causes the database to shut down after each connection is closed, leading to repeated startup costs and increased latency. Disabling it keeps the database online between connections, improving overall responsiveness.",
      "sql_query": "DECLARE @auto_close BIT = (SELECT is_auto_close_on FROM sys.databases WHERE name = DB_NAME());\nIF @auto_close = 1\nBEGIN\n  SELECT\n    DB_NAME() AS table_name,\n    NULL AS column_name,\n    'AUTO_CLOSE is ENABLED: the engine will close and reopen the database on each connection, adding significant overhead.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\nEND\nELSE\nBEGIN\n  SELECT\n    DB_NAME() AS table_name,\n    NULL AS column_name,\n    'AUTO_CLOSE is DISABLED: the database remains open across connections, minimizing repeated startup operations.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result\nEND",
      "recommendation": "To avoid repeated open/close cycles, run:\n```sql\nALTER DATABASE CURRENT SET AUTO_CLOSE OFF;\n```",
      "status": "false",
      "fabric_note": "Disabled: AUTO_CLOSE is managed by Fabric and not user-configurable.",
      "severity": 2,
      "content": "query",
      "level": "database"
    },
    {
      "id": "RL111",
      "category": "Performance",
      "description": "AUTO_SHRINK automatically reclaims free space in the database files, but continuous shrink operations fragment indexes and degrade performance. Disabling it prevents unnecessary I/O and index fragmentation.",
      "sql_query": "DECLARE @auto_shrink BIT = (SELECT is_auto_shrink_on FROM sys.databases WHERE name = DB_NAME());\nIF @auto_shrink = 1\nBEGIN\n  SELECT\n    DB_NAME() AS table_name,\n    NULL AS column_name,\n    'AUTO_SHRINK is ENABLED: automatic file shrink operations will run, causing index fragmentation and higher I/O.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\nEND\nELSE\nBEGIN\n  SELECT\n    DB_NAME() AS table_name,\n    NULL AS column_name,\n    'AUTO_SHRINK is DISABLED: file shrink operations will only run when explicitly executed, preserving index integrity.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result\nEND",
      "recommendation": "To prevent automatic shrink-induced fragmentation, run:\n```sql\nALTER DATABASE CURRENT SET AUTO_SHRINK OFF;\n```",
      "status": "false",
      "fabric_note": "Disabled: AUTO_SHRINK is managed by Fabric and not user-configurable.",
      "severity": 2,
      "content": "query",
      "level": "database"
    },
    {
      "id": "RL112",
      "category": "Performance",
      "description": "AUTO_UPDATE_STATISTICS automatically refreshes column and index distribution statistics when data changes, ensuring the optimizer has up-to-date information to choose the best execution plans.",
      "sql_query": "DECLARE @auto_stats BIT = (SELECT is_auto_update_stats_on FROM sys.databases WHERE name = DB_NAME());\nIF @auto_stats = 0\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'AUTO_UPDATE_STATISTICS is DISABLED: statistics may become stale, leading to suboptimal query plans.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\nEND\nELSE\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'AUTO_UPDATE_STATISTICS is ENABLED: statistics refresh automatically, helping the optimizer generate efficient plans.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result\nEND",
      "recommendation": "To keep statistics current automatically, run:\n```sql\nALTER DATABASE CURRENT SET AUTO_UPDATE_STATISTICS ON;\n```",
      "remediation_template": "ALTER DATABASE {warehouse_name} SET AUTO_UPDATE_STATISTICS ON",
      "status": "true",
      "severity": 2,
      "content": "query",
      "level": "database"
    },
    {
      "id": "RL113",
      "category": "Performance",
      "description": "AUTO_UPDATE_STATISTICS_ASYNC allows queries to continue using existing statistics while updates run asynchronously, preventing query blocking on large tables during stats maintenance.",
      "sql_query": "DECLARE @async_stats BIT = (SELECT is_auto_update_stats_async_on FROM sys.databases WHERE name = DB_NAME());\nIF @async_stats = 0\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'AUTO_UPDATE_STATISTICS_ASYNC is DISABLED: statistics updates will block queries, potentially causing wait times.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\nEND\nELSE\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'AUTO_UPDATE_STATISTICS_ASYNC is ENABLED: statistics updates run in the background, reducing blocking.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result\nEND",
      "recommendation": "To avoid query blocking during stats updates, run:\n```sql\nALTER DATABASE CURRENT SET AUTO_UPDATE_STATISTICS_ASYNC ON;\n```",
      "remediation_template": "ALTER DATABASE {warehouse_name} SET AUTO_UPDATE_STATISTICS_ASYNC ON",
      "status": "true",
      "severity": 2,
      "content": "query",
      "level": "database"
    },
    {
      "id": "RL114",
      "category": "Reliability",
      "description": "PAGE_VERIFY controls the level of page‐header checking. CHECKSUM provides the strongest detection of I/O errors and corruption by verifying data integrity on each I/O operation.",
      "sql_query": "DECLARE @pv_option VARCHAR(60) = (SELECT page_verify_option_desc FROM sys.databases WHERE name = DB_NAME());\nIF @pv_option <> 'CHECKSUM'\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'PAGE_VERIFY is set to ' + @pv_option + ': this option offers weaker corruption checks. CHECKSUM is recommended for robust I/O integrity validation.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\nEND\nELSE\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'PAGE_VERIFY = CHECKSUM: strong protection against I/O corruption is enabled.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result\nEND",
      "recommendation": "To enable the strongest I/O corruption detection, run:\n```sql\nALTER DATABASE CURRENT SET PAGE_VERIFY CHECKSUM;\n```",
      "remediation_template": "ALTER DATABASE {warehouse_name} SET PAGE_VERIFY CHECKSUM",
      "status": "true",
      "severity": 1,
      "content": "query",
      "level": "database"
    },
    {
      "id": "RL115",
      "category": "Concurrency",
      "description": "ALLOW_SNAPSHOT_ISOLATION enables row versioning for explicit snapshot transactions, reducing blocking by allowing readers to access a consistent snapshot without acquiring shared locks.",
      "sql_query": "DECLARE @si_state BIT = (SELECT snapshot_isolation_state FROM sys.databases WHERE name = DB_NAME());\nIF @si_state = 0\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'ALLOW_SNAPSHOT_ISOLATION is DISABLED: readers may block writers and vice versa under high concurrency.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\nEND\nELSE\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'ALLOW_SNAPSHOT_ISOLATION is ENABLED: readers use row versions to avoid blocking writers.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result\nEND",
      "recommendation": "To reduce read/write blocking under heavy load, run:\n```sql\nALTER DATABASE CURRENT SET ALLOW_SNAPSHOT_ISOLATION ON;\n```",
      "remediation_template": "ALTER DATABASE {warehouse_name} SET ALLOW_SNAPSHOT_ISOLATION ON",
      "status": "true",
      "severity": 2,
      "content": "query",
      "level": "database"
    },
    {
      "id": "RL116",
      "category": "Concurrency",
      "description": "READ_COMMITTED_SNAPSHOT changes the default READ COMMITTED isolation to use row versioning, eliminating shared locks for reads and reducing blocking on busy systems.",
      "sql_query": "DECLARE @rcs_state BIT = (SELECT is_read_committed_snapshot_on FROM sys.databases WHERE name = DB_NAME());\nIF @rcs_state = 0\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'READ_COMMITTED_SNAPSHOT is DISABLED: queries under READ COMMITTED will issue shared locks, increasing blocking risk.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\nEND\nELSE\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'READ_COMMITTED_SNAPSHOT is ENABLED: read operations use row versioning, reducing lock contention.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result\nEND",
      "recommendation": "To enable versioned reads by default for READ COMMITTED, run:\n```sql\nALTER DATABASE CURRENT SET READ_COMMITTED_SNAPSHOT ON;\n```",
      "remediation_template": "ALTER DATABASE {warehouse_name} SET READ_COMMITTED_SNAPSHOT ON",
      "status": "true",
      "severity": 2,
      "content": "query",
      "level": "database"
    },
    {
      "id": "RL117",
      "category": "Performance",
      "description": "Forced parameterization causes SQL Server to replace literal values in ad-hoc queries with parameters, dramatically reducing plan cache bloat and improving plan reuse for similar queries.",
      "sql_query": "DECLARE @forced_parm BIT = (SELECT is_parameterization_forced FROM sys.databases WHERE name = DB_NAME());\nIF @forced_parm = 0\nBEGIN\n  SELECT\n    DB_NAME() AS table_name,\n    NULL AS column_name,\n    'FORCED PARAMETERIZATION is OFF: each ad-hoc query with different literals will generate a new plan, leading to plan cache bloat.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\nEND\nELSE\nBEGIN\n  SELECT\n    DB_NAME() AS table_name,\n    NULL AS column_name,\n    'FORCED PARAMETERIZATION is ON: similar ad-hoc queries share a single plan, improving cache efficiency.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result\nEND",
      "recommendation": "To reduce plan cache churn from literal‐heavy workloads, run:\n```sql\nALTER DATABASE CURRENT SET PARAMETERIZATION FORCED;\n```",
      "status": "false",
      "fabric_note": "Disabled: Forced parameterization is not configurable in Fabric Warehouse.",
      "severity": 2,
      "content": "query",
      "level": "database"
    },
    {
      "id": "RL118",
      "category": "Performance",
      "description": "Query Store captures query texts, plans, and runtime statistics over time, enabling you to identify regressions, force good plans, and analyze workload performance trends.",
      "sql_query": "DECLARE @qs_state BIT = (SELECT is_query_store_on FROM sys.databases WHERE name = DB_NAME());\nIF @qs_state = 0\nBEGIN\n  SELECT\n    DB_NAME() AS table_name,\n    NULL AS column_name,\n    'QUERY STORE is DISABLED: historical plan and runtime data is not captured, making troubleshooting regressions difficult.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\nEND\nELSE\nBEGIN\n  SELECT\n    DB_NAME() AS table_name,\n    NULL AS column_name,\n    'QUERY STORE is ENABLED: execution history and plan data are collected for performance analysis.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result\nEND",
      "recommendation": "To enable historical plan capture and analysis, run:\n```sql\nALTER DATABASE CURRENT SET QUERY_STORE = ON;\n```",
      "status": "false",
      "fabric_note": "Disabled: Fabric Warehouse uses Query Insights (queryinsights.*) instead of SQL Server Query Store.",
      "severity": 2,
      "content": "query",
      "level": "database"
    },
    {
      "id": "RL119",
      "category": "Recovery",
      "description": "The SIMPLE recovery model truncates the transaction log on each checkpoint, minimizing log growth. It’s ideal for data-warehouse workloads where point-in-time restore is not required.",
      "sql_query": "DECLARE @rm VARCHAR(60) = (SELECT recovery_model_desc FROM sys.databases WHERE name = DB_NAME());\nIF @rm <> 'SIMPLE'\nBEGIN\n  SELECT\n    DB_NAME() AS table_name,\n    NULL AS column_name,\n    'Recovery model is ' + @rm + ': log will grow until manually truncated. SIMPLE model is recommended for analytics scenarios.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\nEND\nELSE\nBEGIN\n  SELECT\n    DB_NAME() AS table_name,\n    NULL AS column_name,\n    'Recovery model is SIMPLE: log truncation happens automatically on checkpoint.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result\nEND",
      "recommendation": "If point-in-time restore is not needed, switch to SIMPLE:\n```sql\nALTER DATABASE CURRENT SET RECOVERY SIMPLE;\n```",
      "status": "false",
      "fabric_note": "Disabled: Recovery model is managed by Fabric and not user-configurable.",
      "severity": 2,
      "content": "query",
      "level": "database"
    },
    {
      "id": "RL120",
      "category": "Compatibility",
      "description": "Database compatibility level determines which SQL engine behaviors and optimizer features are available. Using a level below the current SQL Server version may prevent you from benefiting from the latest enhancements.",
      "sql_query": "DECLARE @cl INT = (SELECT compatibility_level FROM sys.databases WHERE name = DB_NAME());\nIF @cl < 150\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'Compatibility level is ' + CAST(@cl AS VARCHAR) + ': some modern optimizer improvements are disabled.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\nEND\nELSE\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'Compatibility level is ' + CAST(@cl AS VARCHAR) + ': all current features are available.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result\nEND",
      "recommendation": "To enable the latest query optimizer enhancements, run:\n```sql\nALTER DATABASE CURRENT SET COMPATIBILITY_LEVEL = 150;\n```",
      "remediation_template": "ALTER DATABASE {warehouse_name} SET COMPATIBILITY_LEVEL = 150",
      "status": "true",
      "severity": 2,
      "content": "query",
      "level": "database"
    },
    {
      "id": "RL121",
      "category": "Standards",
      "description": "ANSI SQL settings and QUOTED_IDENTIFIER impact parsing, plan caching, and result correctness. Ensuring ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT and QUOTED_IDENTIFIER are all ON avoids subtle bugs and improves plan reuse.",
      "sql_query": "DECLARE @flags INT = (SELECT\n    CASE WHEN is_ansi_nulls_on = 1 THEN 1 ELSE 0 END +\n    CASE WHEN is_ansi_padding_on = 1 THEN 1 ELSE 0 END +\n    CASE WHEN is_ansi_warnings_on = 1 THEN 1 ELSE 0 END +\n    CASE WHEN is_arithabort_on = 1 THEN 1 ELSE 0 END +\n    CASE WHEN is_quoted_identifier_on = 1 THEN 1 ELSE 0 END\n  FROM sys.databases WHERE name = DB_NAME());\nIF @flags < 5\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'One or more ANSI/QUOTED_IDENTIFIER settings are OFF: this can lead to unpredictable query behavior and plan cache misses.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\nEND\nELSE\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'All ANSI and QUOTED_IDENTIFIER settings are ON: queries behave predictably and benefit from plan reuse.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result\nEND",
      "recommendation": "To enforce standard behavior and plan caching, run:\n```sql\nALTER DATABASE CURRENT SET ANSI_NULLS ON;\nALTER DATABASE CURRENT SET ANSI_PADDING ON;\nALTER DATABASE CURRENT SET ANSI_WARNINGS ON;\nALTER DATABASE CURRENT SET ARITHABORT ON;\nALTER DATABASE CURRENT SET QUOTED_IDENTIFIER ON;\n```",
      "remediation_template": "ALTER DATABASE {warehouse_name} SET ANSI_NULLS ON; ALTER DATABASE {warehouse_name} SET ANSI_PADDING ON; ALTER DATABASE {warehouse_name} SET ANSI_WARNINGS ON; ALTER DATABASE {warehouse_name} SET ARITHABORT ON; ALTER DATABASE {warehouse_name} SET QUOTED_IDENTIFIER ON",
      "status": "true",
      "severity": 3,
      "content": "query",
      "level": "database"
    },
    {
      "id": "RL123",
      "category": "Availability",
      "description": "If a database is not ONLINE, it cannot accept connections and will cause application failures. Ensuring it is ONLINE guarantees availability.",
      "sql_query": "DECLARE @state VARCHAR(60) = (SELECT state_desc FROM sys.databases WHERE name = DB_NAME());\nIF @state <> 'ONLINE'\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'Database state is ' + @state + ': the database is not accepting connections and is unavailable.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\nEND\nELSE\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'Database is ONLINE: available for client connections.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result\nEND",
      "recommendation": "If the database is not ONLINE, bring it online:\n```sql\nALTER DATABASE CURRENT SET ONLINE;\n```",
      "remediation_template": "ALTER DATABASE {warehouse_name} SET ONLINE",
      "status": "true",
      "severity": 1,
      "content": "query",
      "level": "database"
    },
    {
      "id": "RL124",
      "category": "Access",
      "description": "User access modes (SINGLE_USER, RESTRICTED_USER, MULTI_USER) control how many sessions can connect. MULTI_USER is required for normal operation; other modes block additional connections.",
      "sql_query": "DECLARE @ua VARCHAR(60) = (SELECT user_access_desc FROM sys.databases WHERE name = DB_NAME());\nIF @ua <> 'MULTI_USER'\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'User access mode is ' + @ua + ': normal clients may be blocked from connecting.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\nEND\nELSE\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'User access mode is MULTI_USER: normal client connections are permitted.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result\nEND",
      "recommendation": "To restore normal multi‐user access, run:\n```sql\nALTER DATABASE CURRENT SET MULTI_USER;\n```",
      "remediation_template": "ALTER DATABASE {warehouse_name} SET MULTI_USER",
      "status": "true",
      "severity": 2,
      "content": "query",
      "level": "database"
    },
    {
      "id": "RL125",
      "category": "Performance",
      "description": "Result set caching persists final result sets for applicable SELECT queries, so subsequent runs return cached results faster. Enabled by default in Fabric Warehouse and Lakehouse SQL analytics endpoints.",
      "sql_query": "DECLARE @rsc BIT = (SELECT is_result_set_caching_on FROM sys.databases WHERE name = DB_NAME());\nIF @rsc = 0\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'Result set caching is DISABLED: repeated deterministic queries will re-execute each time, consuming resources. Note: Result set caching is enabled by default in Fabric and should generally remain on.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\nEND\nELSE\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'Result set caching is ENABLED: repeated deterministic queries may return cached results, improving throughput. Check queryinsights.exec_requests_history (result_cache_hit column) to verify cache usage.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result\nEND",
      "recommendation": "Result set caching is enabled by default in Fabric. To re-enable if disabled, run: ALTER DATABASE <name> SET RESULT_SET_CACHING ON. Check cache usage via queryinsights.exec_requests_history (result_cache_hit: 2=hit, 1=created, 0=not applicable).",
      "remediation_template": "ALTER DATABASE {warehouse_name} SET RESULT_SET_CACHING ON",
      "status": "true",
      "severity": 2,
      "content": "query",
      "level": "database"
    },
    {
      "id": "RL126",
      "category": "Maintenance",
      "description": "Database containment controls cross-database dependencies. NONE is the simplest containment level, avoiding unexpected external dependencies in database-scoped settings.",
      "sql_query": "DECLARE @cnt VARCHAR(60) = (SELECT containment_desc FROM sys.databases WHERE name = DB_NAME());\nIF @cnt <> 'NONE'\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'Containment is set to ' + @cnt + ': external dependencies or cross-database settings may apply.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\nEND\nELSE\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'Containment = NONE: database settings are self-contained, simplifying management.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result\nEND",
      "recommendation": "Unless you specifically require contained database features, run:\n```sql\nALTER DATABASE CURRENT SET CONTAINMENT = NONE;\n```",
      "status": "true",
      "severity": 2,
      "content": "query",
      "level": "database"
    },
    {
      "id": "RL127",
      "category": "Reliability",
      "description": "The clean shutdown flag indicates whether the database was shut down gracefully. A clean shutdown reduces recovery time on restart.",
      "sql_query": "DECLARE @clean BIT = (SELECT is_cleanly_shutdown FROM sys.databases WHERE name = DB_NAME());\nIF @clean = 0\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'Database was NOT cleanly shut down: recovery on restart may take longer.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\nEND\nELSE\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'Database was cleanly shut down: fast recovery expected.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result\nEND",
      "recommendation": "Ensure controlled shutdowns (e.g. via HA failover or maintenance scripts) to maintain fast recovery times.",
      "status": "true",
      "severity": 1,
      "content": "query",
      "level": "database"
    },
    {
      "id": "RL128",
      "category": "Maintenance",
      "description": "Full-text search enables text indexing but incurs storage and maintenance overhead. Disable it if not actively used.",
      "sql_query": "DECLARE @ft BIT = (SELECT is_fulltext_enabled FROM sys.databases WHERE name = DB_NAME());\nIF @ft = 1\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'Full-text search is ENABLED: if not in use, this allocates extra catalogs and resources.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\nEND\nELSE\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'Full-text search is DISABLED: no unnecessary resources consumed.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result\nEND",
      "recommendation": "If you do not perform full-text queries, run:\n```sql\nALTER DATABASE CURRENT SET FULLTEXT OFF;\n```",
      "status": "true",
      "severity": 3,
      "content": "query",
      "level": "database"
    },
    {
      "id": "RL129",
      "category": "Data Management",
      "description": "Data retention features (change feed, temporal tables) preserve historical versions. If you need time-travel queries or change tracking, ensure retention is enabled.",
      "sql_query": "DECLARE @dr BIT = (SELECT is_data_retention_enabled FROM sys.databases WHERE name = DB_NAME());\nIF @dr = 0\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'Data retention is DISABLED: historical data versions are not preserved, limiting audit and time-travel capabilities.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\nEND\nELSE\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'Data retention is ENABLED: historical versions and change feeds are retained.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result\nEND",
      "recommendation": "If you require auditing or time-travel features, run:\n```sql\nALTER DATABASE CURRENT SET DATA_RETENTION = ON;\n```",
      "status": "true",
      "severity": 2,
      "content": "query",
      "level": "database"
    },
    {
      "id": "RL038",
      "category": "Maintainability",
      "description": "Detect views with deep nesting (more than 3 levels) that can degrade performance and maintainability.",
      "sql_query": "SELECT v.name AS table_name, NULL AS column_name, 'View ' + v.name + ' references ' + CAST(COUNT(d.referenced_id) AS VARCHAR(5)) + ' other objects. Review for excessive dependencies.' + CHAR(10) + CHAR(10) + CASE WHEN COUNT(d.referenced_id) > 10 THEN 'Indicator: Anomaly - ERR_1001' ELSE 'Indicator: Optimized - OPT_2001' END AS result FROM sys.views v LEFT JOIN sys.sql_expression_dependencies d ON v.object_id = d.referencing_id WHERE SCHEMA_NAME(v.schema_id) NOT IN ('sys','INFORMATION_SCHEMA','queryinsights') GROUP BY v.name UNION ALL SELECT NULL AS table_name, NULL AS column_name, 'No user views found in the database.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result WHERE NOT EXISTS (SELECT 1 FROM sys.views WHERE SCHEMA_NAME(schema_id) NOT IN ('sys','INFORMATION_SCHEMA','queryinsights'))",
      "recommendation": "Simplify view chains to at most 3 levels of nesting. Deep nesting causes the query optimizer to produce suboptimal plans and makes troubleshooting very difficult.",
      "status": "true",
      "severity": 2,
      "content": "query",
      "level": "schema"
    },
    {
      "id": "RL039",
      "category": "Maintainability",
      "description": "Detect completely empty tables (0 rows) that may be unused or abandoned.",
      "sql_query": "IF EXISTS (\n  SELECT 1\n  FROM sys.tables t\n  JOIN sys.partitions p ON t.object_id = p.object_id\n  WHERE p.index_id IN (0,1) AND t.is_ms_shipped = 0\n  GROUP BY t.schema_id, t.name\n  HAVING SUM(p.rows) = 0\n)\nBEGIN\n  SELECT\n    SCHEMA_NAME(t.schema_id) + '.' + t.name AS table_name,\n    NULL AS column_name,\n    'Table ''' + t.name + ''' is completely empty (0 rows). This may indicate an unused, abandoned, or incorrectly loaded table. Consider removing it or verifying the data pipeline.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\n  FROM sys.tables t\n  JOIN sys.partitions p ON t.object_id = p.object_id\n  WHERE p.index_id IN (0,1) AND t.is_ms_shipped = 0\n  GROUP BY t.schema_id, t.name\n  HAVING SUM(p.rows) = 0\n  ORDER BY t.name;\nEND\nELSE\nBEGIN\n  SELECT\n    NULL AS table_name,\n    NULL AS column_name,\n    'No empty tables found. All tables contain data.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result;\nEND",
      "recommendation": "Empty tables waste metadata space and can confuse users. Remove them if they are no longer needed, or investigate why data pipelines are not populating them.",
      "status": "true",
      "severity": 3,
      "content": "query",
      "level": "table"
    },
    {
      "id": "RL040",
      "category": "Maintainability",
      "description": "Check if schemas have documentation via extended properties (MS_Description).",
      "sql_query": "DECLARE @has_issue BIT = 0;\n\nIF EXISTS (\n  SELECT 1\n  FROM sys.schemas s\n  LEFT JOIN sys.extended_properties ep\n    ON ep.class = 3 AND ep.major_id = s.schema_id AND ep.name = 'MS_Description'\n  WHERE s.name NOT IN ('sys','INFORMATION_SCHEMA','guest','db_owner','db_accessadmin','db_securityadmin','db_ddladmin','db_backupoperator','db_datareader','db_datawriter','db_denydatareader','db_denydatawriter','queryinsights')\n    AND ep.value IS NULL\n)\nBEGIN\n  SET @has_issue = 1;\n  SELECT\n    s.name AS table_name,\n    NULL AS column_name,\n    'Schema ''' + s.name + ''' lacks documentation (MS_Description extended property). Documenting schemas improves discoverability and onboarding.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\n  FROM sys.schemas s\n  LEFT JOIN sys.extended_properties ep\n    ON ep.class = 3 AND ep.major_id = s.schema_id AND ep.name = 'MS_Description'\n  WHERE s.name NOT IN ('sys','INFORMATION_SCHEMA','guest','db_owner','db_accessadmin','db_securityadmin','db_ddladmin','db_backupoperator','db_datareader','db_datawriter','db_denydatareader','db_denydatawriter','queryinsights')\n    AND ep.value IS NULL\n  ORDER BY s.name;\nEND\n\nIF @has_issue = 0\nBEGIN\n  SELECT NULL AS table_name, NULL AS column_name, 'All user schemas are documented with MS_Description extended properties.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result;\nEND",
      "recommendation": "Add documentation to schemas using extended properties to improve discoverability and maintainability for team members.",
      "status": "true",
      "severity": 3,
      "content": "query",
      "level": "schema"
    },
    {
      "id": "RL041",
      "category": "Data Quality",
      "description": "Identify important columns that lack DEFAULT constraints, which can cause NULL insertions or insert failures.",
      "sql_query": "DECLARE @has_issue BIT = 0;\n\nIF EXISTS (\n  SELECT 1\n  FROM sys.tables t\n  JOIN sys.columns c ON t.object_id = c.object_id\n  LEFT JOIN sys.default_constraints dc ON c.object_id = dc.parent_object_id AND c.column_id = dc.parent_column_id\n  WHERE t.is_ms_shipped = 0\n    AND dc.object_id IS NULL\n    AND c.is_nullable = 0\n    AND c.is_identity = 0\n    AND c.is_computed = 0\n)\nBEGIN\n  SET @has_issue = 1;\n  SELECT\n    SCHEMA_NAME(t.schema_id) + '.' + t.name AS table_name,\n    c.name AS column_name,\n    'NOT NULL column ''' + c.name + ''' in table ''' + t.name + ''' has no DEFAULT constraint. INSERT statements that omit this column will fail.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\n  FROM sys.tables t\n  JOIN sys.columns c ON t.object_id = c.object_id\n  LEFT JOIN sys.default_constraints dc ON c.object_id = dc.parent_object_id AND c.column_id = dc.parent_column_id\n  WHERE t.is_ms_shipped = 0\n    AND dc.object_id IS NULL\n    AND c.is_nullable = 0\n    AND c.is_identity = 0\n    AND c.is_computed = 0\n  ORDER BY t.name, c.name;\nEND\n\nIF @has_issue = 0\nBEGIN\n  SELECT NULL AS table_name, NULL AS column_name, 'All NOT NULL columns have DEFAULT constraints or are identity columns.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result;\nEND",
      "recommendation": "Add DEFAULT constraints to NOT NULL columns to prevent insert failures and improve data pipeline robustness.",
      "status": "true",
      "severity": 2,
      "content": "query",
      "level": "table"
    },
    {
      "id": "RL042",
      "category": "Data Quality",
      "description": "Detect circular foreign key relationships that can cause deadlocks or cascade issues.",
      "sql_query": "IF EXISTS (\n  SELECT 1 FROM sys.foreign_keys fk1\n  JOIN sys.foreign_keys fk2 ON fk1.referenced_object_id = fk2.parent_object_id\n  WHERE fk1.parent_object_id = fk2.referenced_object_id\n)\nBEGIN\n  SELECT\n    OBJECT_SCHEMA_NAME(fk1.parent_object_id) + '.' + OBJECT_NAME(fk1.parent_object_id) AS table_name,\n    NULL AS column_name,\n    'Circular FK detected: ' + OBJECT_NAME(fk1.parent_object_id) + ' <-> ' + OBJECT_NAME(fk1.referenced_object_id) + '. Circular references can cause cascade issues.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\n  FROM sys.foreign_keys fk1\n  JOIN sys.foreign_keys fk2 ON fk1.referenced_object_id = fk2.parent_object_id\n  WHERE fk1.parent_object_id = fk2.referenced_object_id;\nEND\nELSE\nBEGIN\n  SELECT NULL AS table_name, NULL AS column_name, 'No circular foreign key relationships detected.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result;\nEND",
      "recommendation": "Refactor circular foreign key relationships. Use application-level integrity checks or deferred constraints instead of circular cascading references.",
      "status": "true",
      "severity": 2,
      "content": "query",
      "level": "table"
    },
    {
      "id": "RL043",
      "category": "Maintainability",
      "description": "Detect cross-schema dependencies in views and stored procedures that may complicate deployment and maintenance.",
      "sql_query": "DECLARE @has_issue BIT = 0;\n\nIF EXISTS (\n  SELECT 1\n  FROM sys.sql_expression_dependencies d\n  JOIN sys.objects o ON d.referencing_id = o.object_id\n  JOIN sys.objects ref ON d.referenced_id = ref.object_id\n  WHERE o.schema_id <> ref.schema_id\n    AND o.type IN ('V','P','FN','IF','TF')\n    AND SCHEMA_NAME(o.schema_id) NOT IN ('sys','INFORMATION_SCHEMA','queryinsights')\n    AND SCHEMA_NAME(ref.schema_id) NOT IN ('sys','INFORMATION_SCHEMA','queryinsights')\n)\nBEGIN\n  SET @has_issue = 1;\n  SELECT\n    SCHEMA_NAME(o.schema_id) + '.' + o.name AS table_name,\n    SCHEMA_NAME(ref.schema_id) + '.' + ref.name AS column_name,\n    'Object ''' + SCHEMA_NAME(o.schema_id) + '.' + o.name + ''' references ''' + SCHEMA_NAME(ref.schema_id) + '.' + ref.name + ''' across schemas. Cross-schema dependencies can complicate deployments and increase coupling.' + CHAR(10) + CHAR(10) + 'Indicator: Anomaly - ERR_1001' AS result\n  FROM sys.sql_expression_dependencies d\n  JOIN sys.objects o ON d.referencing_id = o.object_id\n  JOIN sys.objects ref ON d.referenced_id = ref.object_id\n  WHERE o.schema_id <> ref.schema_id\n    AND o.type IN ('V','P','FN','IF','TF')\n    AND SCHEMA_NAME(o.schema_id) NOT IN ('sys','INFORMATION_SCHEMA','queryinsights')\n    AND SCHEMA_NAME(ref.schema_id) NOT IN ('sys','INFORMATION_SCHEMA','queryinsights')\n  ORDER BY SCHEMA_NAME(o.schema_id), o.name;\nEND\n\nIF @has_issue = 0\nBEGIN\n  SELECT NULL AS table_name, NULL AS column_name, 'No cross-schema dependencies found. All objects reference within their own schema.' + CHAR(10) + CHAR(10) + 'Indicator: Optimized - OPT_2001' AS result;\nEND",
      "recommendation": "Minimize cross-schema dependencies for cleaner modular architecture. If cross-schema access is intentional, document it clearly.",
      "status": "true",
      "severity": 3,
      "content": "query",
      "level": "schema"
    }
  ]
}